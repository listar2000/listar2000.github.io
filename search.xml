<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>greetings!</title>
      <link href="/2018/07/24/greetings/"/>
      <url>/2018/07/24/greetings/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Star&#39;s Awesome Collections 炫酷编程学习资料（持续更新）</title>
      <link href="/2018/06/28/Star-s-Awesome-Collections/"/>
      <url>/2018/06/28/Star-s-Awesome-Collections/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/github_logo.gif" alt=""></p><h2 id="说在前面："><a href="#说在前面：" class="headerlink" title="说在前面："></a>说在前面：</h2><p>我虽然在初中开始就有过一段时间的Visual Basic编程经历，但是正式的系统学习CS则是在高三选修 <code>AP CS</code>  课之后才开始的。在这短短的不到一年时间内，我一方面得到了学校内外许许多多高手的帮助(这里就不一一点名)，另一方面也自己走了很多弯路。半年前傻乎乎买过的《Java Web一月速通》现在在书架上落了不知道多少层灰，在bilibili上想学习Java却点进Javascript视频也不在少数。</p><p>然鹅，这些努力都没有白费。整个过程中，我感受到了这个时代开源编程社区以及问答社区（如知乎，StackOverflow）对于新手的友好；完整生动的文档（Vue，MyBatis）让我这种小白少走非常多的弯路。同时，Github，CSDN，甚至B站上有非常多良心的UP主带来深刻又清晰的教程。这里我整理了一份Awesome XXX系列的，个人认为非常不错的，资料–并且一直会更新。</p><p>虽然我的编程技术不够好，带来的东西的“深度”或许不入很多人的法眼；但这些东西都是能够让新手少走弯路，迅速入门的哦！</p><a id="more"></a><h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><p>大致分为几个部分：</p><ol><li>Java学习</li><li>Python学习</li><li>前端学习</li><li>开源项目</li></ol><h2 id="Java学习："><a href="#Java学习：" class="headerlink" title="Java学习："></a>Java学习：</h2><p><a href="https://www.amazon.cn/dp/B01M06CLQM/ref=sr_1_1?ie=UTF8&amp;qid=1530117552&amp;sr=8-1&amp;keywords=Core+Java" target="_blank" rel="noopener">Core Java 核心编程思想（卷I）</a></p><p>卷1是非常好的入门学习资料，即使精通Java也可以当作手册使用。卷2更加进阶但是没有普适性，故不推荐。</p><p><a href="https://www.amazon.cn/dp/0134685997/ref=sr_1_3?ie=UTF8&amp;qid=1530117722&amp;sr=8-3&amp;keywords=effective+java" target="_blank" rel="noopener">Effective Java 3rd Edition</a></p><p>第三版只有英文版，加入了Java 8新特性。该书是Java进阶的必读之作，我只读了1/4不到。上面两本都能找到电子版，链接是亚马逊的。</p><p><a href="https://my.csdn.net/javazejian" target="_blank" rel="noopener">CSDN Zejian的系列博客</a></p><p>Zejian大神的博客既有图文并茂的数据结构基础内容，也有对于Java特殊机制(并发，迭代接口等)的详细讲解，值得一读。</p><p><a href="https://biezhi.me/" target="_blank" rel="noopener">Biezhi（王爵）的一系列分享</a></p><p>Biezhi大神是Github上Java Web框架Blade的作者，同时热衷搞开源项目。上为其个人主页，可通向如Github，知乎等平台。</p><p>下面是他的B站账号，很多视频非常良心：</p><p><a href="https://space.bilibili.com/33165125/#/" target="_blank" rel="noopener">魔王不造反的个人空间 - 哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili</a></p><p>推荐视频有：</p><ol><li>跟上Java 8</li><li>技术小黑屋</li></ol><p><a href="https://www.bilibili.com/video/av10274225?from=search&amp;seid=9614513947039600494" target="_blank" rel="noopener">B站极客学院Java Web系列课程</a></p><p>从最原始的Servlet，JSP教到后面的框架使用，搭配数据库知识学习。唯一缺点就是信息量太大了😄。</p><p><a href="https://www.zhihu.com/people/rednaxelafx" target="_blank" rel="noopener">知乎R大的回答（JVM，编译原理方向）</a></p><p>R大原本是阿里巴巴的大神，专攻Java，JS VM方向。他的许多对于Java底层实现的文章非常细致详细–一定不能错过。</p><p><a href="https://www.coursera.org/learn/algorithms-part1/home/welcome" target="_blank" rel="noopener">Coursera神课: 普林斯顿Algorithm</a></p><p>算法入门课程，使用Java语言教授，可以在学习算法的同时了解OOP编程的诸多知识和Java的细节。五星推荐!</p><h2 id="Python学习："><a href="#Python学习：" class="headerlink" title="Python学习："></a>Python学习：</h2><p>注：我4月份开始因为网络爬虫的需要才接触了Python编程，所以这方面积累的资料不是很多。</p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰的Python教程</a></p><p>其他语言 -&gt; Python的首选教程（需要一定基础），讲解非常详细，配有习题，且完全免费。个人认为可以达到Coursera顶尖课程水平。</p><p><a href="https://www.bilibili.com/video/av18202461?from=search&amp;seid=4776650938833788315" target="_blank" rel="noopener">崔庆才的Python爬虫教程（视频+书籍）</a></p><p>该大神现为微软小冰组工程师。爬虫涵盖了爬取多种页面(静态html，动态json传数据等等)的方法，同时也会教自己搭建动态IP池，Cookie池技巧，以及各种数据库的使用。强烈推荐爬虫入门。</p><p><a href="https://www.coursera.org/specializations/python" target="_blank" rel="noopener">Coursera上UMich的Programming For Everybody</a></p><p>由于我不是完全的小白，所以只上了这个课程的一部分Using Python to Crawl Web Data。相较于崔大神的视频，这个教程更加小白化，分为从浅到深的5个模块。旁听免费，但是要获得证书是收费的。</p><p><a href="https://cs61a.org/" target="_blank" rel="noopener">UC Berkeley 神课CS 61A (Structure and Interpretation of Computer Programs)</a></p><p>自己学校的CS神课不得不吹一波。使用Python而非传统的Scheme来教授SCIP，是非常经典的编程专业入门课。</p><h2 id="前端学习-amp-开源项目"><a href="#前端学习-amp-开源项目" class="headerlink" title="前端学习 &amp; 开源项目"></a>前端学习 &amp; 开源项目</h2><p>这两点放在一起是因为，说来惭愧，我并没有系统的去学习“现代”前端知识，我唯一跟过的网课讲的也是基本的html，css，js以及jquery这些。无论是现在前端组件化，工程化，NodeJS中间件，还是类似SASS这样的层叠样式结构我 <strong>通通不会！！</strong> 反而，由于编程社的项目需要倒逼我上Github看了一些开源的框架。</p><p><a href="https://www.bilibili.com/video/av10298843?from=search&amp;seid=3864072384851945982" target="_blank" rel="noopener">极客学院H5+CSS+JS基本教程</a></p><p>最为基础的教程。HTML毕竟是Markup Language，甚至不需要多少的编程基础都可以学会使用（类似于枯燥版的拼图）。JS讲的也不错。</p><p><a href="https://www.bilibili.com/video/av13450835?from=search&amp;seid=37419470350409929" target="_blank" rel="noopener">Vue.js视频教程–表严肃</a></p><p>看过这么多Vue教程中最好的一个了，可以结合Vue本身精美的文档食用。</p><p><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue.js By Evan You</a></p><p>当今三大前端框架之一，前不久在Github上已经超越React成为Star数量第一（虽然说明不了太多，但是人气爆棚）。简单易用，双向绑定。<br>顺便一提，Vue.js的文档真的是好到没话说…顺便同样强推Vue-router以及全家桶。</p><p><a href="http://www.bootcss.com" target="_blank" rel="noopener">Bootstrap中文站</a></p><p>非常多网站都在使用的前端框架。如果不太会前端，这个框架的栅格系统和自带组件直接省去了很多写CSS的麻烦（超爽有木有）。</p><p><a href="https://www.mdui.org/" target="_blank" rel="noopener">MDUI - 妈的UI??</a></p><p>编程社千年如一日使用的前端框架，国人开发，同样简单易用 (&gt;_&lt;)</p><h1 id="TO-BE-CONTINUED"><a href="#TO-BE-CONTINUED" class="headerlink" title="TO BE CONTINUED"></a>TO BE CONTINUED</h1>]]></content>
      
      
    </entry>
    
    <entry>
      <title>mysql_proxy_pool项目开发</title>
      <link href="/2018/06/17/mysql-proxy-pool%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
      <url>/2018/06/17/mysql-proxy-pool%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<p>mysql_proxy_pool是一个基于 <code>oracle</code> 数据库 <code>mysql</code> 的动态代理池python项目。在以后的版本中会进一步加入对redis,mongodb,sqlite等其他数据库的支持。</p><p><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/carbon.png" alt="图片无意义"></p><a id="more"></a><h2 id="项目特性Features"><a href="#项目特性Features" class="headerlink" title="项目特性Features"></a>项目特性Features</h2><ul><li>可配置的参数，包括lower/higher thresholds用于动态扩容代理池。</li><li>动态检测已有代理–剔除失效代理，动态从国内代理网站爬取代理（异步检测，爬取）。</li><li>提供以flask作为http框架的flask接口获取代理。</li></ul><h2 id="项目依赖（可能）dependencies"><a href="#项目依赖（可能）dependencies" class="headerlink" title="项目依赖（可能）dependencies"></a>项目依赖（可能）dependencies</h2><ul><li>Flask</li><li>aiohttp</li><li>requests</li></ul><h2 id="上线时间-open-time"><a href="#上线时间-open-time" class="headerlink" title="上线时间 open time"></a>上线时间 open time</h2><h3 id="2018-6-28-Update"><a href="#2018-6-28-Update" class="headerlink" title="2018.6.28 Update:"></a>2018.6.28 Update:</h3><p>已经完成了基本框架的搭建，包括基于aiohttp的异步web server以及数据库连接池工具的编写。可成功利用异步io快速爬取kuaidaili网站的免费ip，预计后面会加入更多ip网站的爬取方法。</p><h2 id="Python版本要求"><a href="#Python版本要求" class="headerlink" title="Python版本要求"></a>Python版本要求</h2><p>3.5以上（如果版本为3.4，请手动改写async/await,即使用@asyncio.coroutine装饰器以及yield from语法代替）</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>我也曾是那般狂妄的少年</title>
      <link href="/2018/05/30/%E7%8B%82%E5%A6%84%E7%9A%84%E6%88%91/"/>
      <url>/2018/05/30/%E7%8B%82%E5%A6%84%E7%9A%84%E6%88%91/</url>
      <content type="html"><![CDATA[<p>沉静在<strong>Diss他人</strong>快感中的人，又是否想过<font color="red"> <strong>被群起而攻之</strong> </font>时自己狼狈不堪的下场呢？</p><p><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/%E9%94%AE%E7%9B%98%E4%BE%A0.jpg" alt="Keyboard Man"></p><a id="more"></a><p>今天下午看到了那个闹得沸沸扬扬的知乎回答时，我毫不犹豫的完成了一次漂亮的“反对”+“没有帮助”+“举报”三连。我没有到评论区理论或者骂人，因为我竟然在这位匿名学弟（or学妹，暂且算作学弟）的行文中看到了自己曾经的影子，也看到了那些我曾经做过而现在却后悔莫及的事。</p><p>后来这位同学的回答愈来愈稀奇古怪，什么“Lofter”上看的，什么“不是HFI的”等等自相矛盾的话语接踵而至。我想他恐怕也是心神不安的吧。知乎的匿名答题机制是他最后一道保护罩；他估计也不知道自己会不会被识破，以及识破后的后果如何吧。</p><p>我希望这个答案能被举报，因为我不希望流言蜚语被大肆传播，同时也希望能给这个不成熟的同学一个台阶下（在他依然固执的情况下）。<strong>毕竟，我也曾是那般狂妄的少年。</strong></p><font color="green"><strong>时间回到高一暑假…</strong></font><p>那时，我在金融社风头正盛，参加完几次商赛后变得有点不可一世，基本上就是感觉谁都是辣鸡那种。</p><p>我在暑假期间以学指身份参加了广州几所国际学校联合举办的一个商赛（下以P商赛代称）。心高气盛的我带领着一支HFI金融社的学指队伍，渴望“征服”珠江之滨。</p><p>回过头看，那几天商赛的进程可以算是顺利。虽然有些许摩擦和中断，但至少整个系统还是在有条不紊的进行着。可对于当时的我，很多再平常不过的失误都可以成为大肆批评一番的对象。我批评着，嘲讽着P商赛的种种不足–毕竟他们和理想主义的我的心中那种“高大上”的比赛有着太大的差距；最牛逼的地方在于，我在商赛最后一天洋洋洒洒的写出一篇自认为的大作–<font color="red"><strong>《P商赛的失败给我们的教训》</strong></font>，并在金融社内大肆传播。</p><p>可能我当时比这个匿名同学还要吊上许多吧，毕竟这篇大作的开头可是有“李思达”三个20号字体镇楼的。</p><p>后来呢，相信很多金融社的同学都知道，这篇文章被某位社员“不小心”泄露到多所学校的商赛交流群内，轰动一时。当时的金融社社长唐臣可以说为了帮我擦屁股忙的焦头烂额，那位社员也不得不道歉息事宁人。</p><p>而我呢？我不得不考虑我从没想过的一个问题：<strong>Diss完别人之后被发现咋办？</strong> 那段时间，我几乎删掉了所有和外校有联系的商赛微信群，无时无刻不在想着怎么给出合理的解释。我相信此时此刻那位匿名同学也能够分享我当时的心境吧。</p><p>我更想说的是，很多我狂妄的，自以为是的言论，都只是自己幼稚和极端理想主义的体现，也就是所谓的未经世事。再后来我当上社长之后，我真正了解到办好一个商赛需要付出多少的时间来准备和调试，知道想要避免所有的错误基本上就是无稽之谈。<strong>我明白很多时候比起过分追求细节的完美，能够完整顺利的控制整个商赛的大局更加难能可贵。</strong></p><p>我发现了P商赛那么多的好，可当初满目都是它的坏。</p><p>我后悔，却又后悔莫及。我丧失了那几所学校对HFI金融社起码的信任，这给我宣传自己商赛的时候带来巨大的难题；我和那次商赛的负责人–一位之前认识多年的老友–失去了联络；本来我可以向他请教，取经，但这一切都因为我的狂妄和傲慢而白白葬送。</p><p>我想这位匿名同学犯了和我一样同样的错误：</p><p>他以为，或者说要求，上剑桥，CMU，JHU的学长学姐都是完美无瑕的圣人，在感情方面不能移情别恋，否则就是“婊子”或“狗“。一见钟情或者坚守一生的确难能可贵，但难道寻找一段新的恋情就低人一等吗？</p><p>同样的，他认为所谓优秀学校的学生就不能在他逻辑不通时骂人，否则就是“没有素质”，全然不顾很多评论都是在讲道理和说逻辑。勇于发声和反对垃圾不实谣言和消息，是我们HFI学生扎根于血统中的精神，我为他们感到骄傲。</p><p>匿名的这位同学啊，请恕我引用《心灵捕手》中的台词劝告你，同时题型自己</p><p><strong>“你只是个孩子，你根本不晓得你在说什么。问你艺术，你可能会提出艺术书籍中的粗浅论调，有关米开朗基罗，你知道很多，他的满腔政治热情，他与教皇相交莫逆，和他的耽于性爱，你对他很清楚吧？但你知道西斯汀教堂的气味吗？你没试过站在那儿，昂首眺望天花板上的名画吧？你肯定未见过吧？ 如果我问关于女人的事，你大可以向我如数家珍，你可能上过几次床，但你没法说出在女人身旁醒来时，那份内心真正的喜悦。你年轻彪悍，我如果和你谈论战争，你大可以会向我大抛莎士比亚，背诵“共赴战场，亲爱的朋友“，但你从未亲临战阵，未试过把挚友的头拥入怀里，看着他吸着最后一口气，凝望着你，向你求助。我问你何为爱情，你可能会吟风弄月，但你未试过全情投入真心倾倒”</strong></p><p>如果你真的是一个junior学生，希望你在经历过申请季的喜怒哀乐，经历一段意义非凡的恋情后，重新回过头来审视自己回答中的“感情观”和各种观。</p><p>然后，希望你能够删除掉知乎上的答案，说一句道歉。</p><p>这并不可耻，毕竟，我也曾是那般狂妄的少年。</p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>心态，信心，与战略：wl转正终极攻略</title>
      <link href="/2018/05/17/%E7%BE%8E%E6%9C%AC%E7%94%B3%E8%AF%B7wl%E8%BD%AC%E6%AD%A3%E6%94%BB%E7%95%A5/"/>
      <url>/2018/05/17/%E7%BE%8E%E6%9C%AC%E7%94%B3%E8%AF%B7wl%E8%BD%AC%E6%AD%A3%E6%94%BB%E7%95%A5/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/Berkeley%E5%A3%81%E7%BA%B8.png" alt="图文无关 (X_D)"></p><p><strong>笔者</strong>自己的2018 Fall美本申请在前几天刚刚落下帷幕。本应该早在四月初收尾的申请季，由于一封waitlist的存在被强行延长了一月。而幸运的是，我在这一个月内为这封wl的奔波和努力最终都有了成效–我最终如愿以偿的被 UC Berkeley 录取。在号称“最难申请季”的今年，能以伯克利收尾，我已经非常满意。这里也想分享诸多wl转正的攻略以供学弟学妹参考。</p><a id="more"></a><p><b>注：</b>延迟录取在非常多的情况下属于<b>“courtesy waitlist”</b>，也就是说最终转正的几率非常的小。<font color="red">这篇文章会讲述如何最大化转正的可能，但是最终结果还是有很多运气的成分！</font></p><h3><b style="color: red">TIP0: 心态很重要</b></h3><br>你点开录取结果，发现屏幕上没有出现期待已久的彩带 or 烟花特效。焦急的你或许尝试刷新页面，期待着系统出了故障，可一次次毫无变化的网页击碎了你的最后一丝念想。接着，你带着不安的心情匆匆扫过前几行文字，那个期盼已久的”congratulations”迟迟没有到来，只留下敷衍的<strong>“the result of your application doesn’t reflect your ability”</strong>。<br><br><br><center style="color: orange"><b>“噢，我被reject了!”</b></center><br><br>这时候，你往往沉浸在没有被录取的悲伤之中，却无心去留意自己到底是被拒绝还是收到了waitlist（至少我在ED宾大的时候就错把defer当成了reject）。振作起来！如果你收到了waitlist，就代表着这个学校的招生办（至少对于大部分学校）对于你有着这两种印象：<br><br>1. <strong>这个学生不错</strong>，申请材料各方面没有明显的短板，但是由于 qualified students 太多 (或者留给国际生学位不够），还是放在wl里面等着先吧。<br>2. <strong>这个学生还可以，但是没达到进入我们学校的标准</strong>。为了给他留个不差的印象，给个wl安慰一下吧（也就是所谓的 courtesy waitlist）。<br><br>作为不幸中的万幸，大家肯定都期待着第一种情况。对于第二种情况，不仅和直接翠拒无异，而且还会浪费同学们大量的时间和精力去写一些毫无意义的love letter和emails。<br><br><font color="blue">那么，到底如何分清第一种和第二种waitlist呢？</font><br><br>最好的办法便是查看这所学校往年的 <strong>wl转正率</strong>。<br><br><h3><b style="color: red">TIP1: 查看学校往年WL转正率</b></h3><p>我们先看一下大体的情况：</p><p><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/sina_rate.png" alt="此处输入图片的描述"></p><p><strong>从上图可以看到</strong>，大多数的大学其实都在发放所谓的 courtesy waitlist。2016年的数据表明，wl转正的平均概率是18%，而大多数大学的转正率都在10%之下。<br><strong>但另一方面</strong>，仍然有16%的学校转正率在40%以上（其中包括了一些有名的加州大学），意味着被这些学校wl的学生有很大几率可以最终转正。</p><p>详细来讲，截取 <a href="http://www.sohu.com/a/136193436_322995" target="_blank" rel="noopener">搜狐教育</a> 的文章数据，几所知名大学2016年的wl数据如下：</p><table><thead><tr><th>学校</th><th>wl转正人数</th><th>转正率</th></tr></thead><tbody><tr><td>Amherst</td><td>3</td><td>1%</td></tr><tr><td>Boston College</td><td>112</td><td>4%</td></tr><tr><td>Case Western</td><td>333</td><td>7%</td></tr><tr><td>Cornell</td><td>61</td><td>2%</td></tr><tr><td>Dartmouth</td><td>16</td><td>1%</td></tr><tr><td>UC Berkeley</td><td>1340</td><td>55%</td></tr><tr><td>UC Davis</td><td>2571</td><td>83%</td></tr></tbody></table><p><strong>其中可以看出：</strong><br>假如你被康奈尔或者达特茅斯之藤校 wl，就告诉自己被拒了吧。各位数的转正率可是比申请时的录取率还低了几个档次的。<br>然而，假如你像我一样，被UCB或者UCD给wl了，那么请好好的准备–不乱玩的话，Offer在不远处等你。</p><p>这同时也告诉我们，<strong>如果同时被多所学校waitlist，一定要做好足够调查，分清主次，然后适当的accept wl并准备后续的工作</strong>。</p><p><b style="color: Crimson">个人经验:</b><br>我在申请阶段同时收到了 UCB, Emory, 以及WUSTL的waitlist。而在分析之后，发现除了伯克利之外的学校转正几率非常之低。所以最后决定只接受UCB的wl并且全力准备后续的材料。</p><p>做好了这一步之后, make your choice &amp; keep running forward。下一步就是后续材料的准备了。</p><h3><b style="color: red">TIP2: 开始准备WL材料满足要求</b></h3><br>虽然说查看waitlist补充材料和要求也应该是最开始就做的事情，但是我相信只有下定决心去最后一搏时，各位同学才有兴趣去仔细的准备。<br><br>如同差距巨大的waitlist录取率，不同美国大学的材料要求也是各有不同。大家最为耳熟能详的可能就是升学指导天天叮嘱的 <code>Love Letter</code> 了。但是一个后知后觉的事实却是–这样的材料对于申请人数少的文理学院或者私立学校或许有用，但是明显waitlist人数上千的大U/公立学校是不吃这一套的。<br><br>还是以我比较熟悉的UCB来讲吧。虽说UCB不怎么发waitlist，但是根据上表依然有两千多人在Pool之中。加上公立学校升学指导办的人力资源紧凑，理论上是不可能通过 <strong>常规途径</strong> 去appeal招生官或者来回邮件交谈的。实际上，官网的要求就是submit一封“题目自拟，表达意愿”的额外文书（并且是optional)的–<strong>并且只能</strong>提交一次。<br><br>我们来分析一下，这一封额外文书和love letter有什么重要区别呢？<br>- 只能提交一次。代表着你不能写一封love letter纯煽情表达自己的热爱，然后跟着一封图文并茂的邮件列举自己半年来做过的事情 to prove your qualification。 反而，你要绞尽脑汁在短短百余字内表达完各种心态。<br>- 没有回复。不像邮件，这个文书交上去就音讯全无了（直到wl放榜）。所以那种心中的不安和紧迫感也是非常要命的。<br><br>在我看来，面对这样的文书，一味着去appeal to pathos企图打动招生官是非常不可取的行为。所以，我在我的额外文书中做到了 <strong>热情中带着傲娇</strong> ，这里也简单的分享一下我的经验。<br><br>1. 所谓热情，就是对学校的热爱啦。毕竟WL的时候肯定已经拿到了别的学校的Offer，那么放着现成的大学不去而选择继续等候肯定是有特定原因的。这一点不算难，大家把之前申请阶段时的文书拿过来再看几遍，浏览几遍大学官网，然后结合自身的兴趣爱好就好了。<br><br>2. 傲娇。这里的意思是凡事要有个度，我们不能体现出“求大学爸爸给个Offer，不然我要死了”这样的“卑微”态度；反而，我们需要体现出其实我们是 <strong>配得上你们学校</strong> 的精神气概。尤其要谈一下申请完到现在这段高三时间内，你都干了什么。这里的建议是，对于原本活动列表或者文书中就有提到的活动，你应该说明你仍然坚持没有放弃它们；另一方面，最好可以稍稍介绍一些新的兴趣和爱好。比如我就提到了高三整一年我非常痴迷的Java编程和Web技术。<br><br>3. 我更加“心机”的提到了自己乐观而向上的态度。结合上一条所说，没有大学会喜欢一个因为被waitlist了就伤心欲绝，苦苦哀求的学生（人家说不定担心你哪天想不开跳楼呢）。反而，在重视wl的情况下，大学希望看到你的积极向上，即使没有申请到也依然斗志昂扬的气质。所以，我的第一段是这样的：<br><br>When the disappointing sentence “your application result doesn’t reflect your ability” exhibits on the screen, declaring another rejection or waitlist to my college application, I do not take it as a consolation. As Kelly Clarkson’s lyric “what doesn’t kill you makes you stronger” still resonates inside my brain, I realize more of the meaning of my efforts in continuous studying and developing myself.<br><br>翻译：当“你的大学申请结果不能反映你的能力”出现在我的大学拒信上时，我并不仅仅将它看作一句安慰，而是深深的坚信它的正确性。此时，美国歌手Kelly Clarkson的《那些杀不死你的终将让你更强大》在我耳边响起，而我突然体会到了这几个月来我自己持之以恒的努力和拼搏有多么的珍贵。<br><br>仔细看看，我的技巧在于将“收到拒信”这样一件低落的事情转化为“让自己更强大”的原动力，从而体现出自己的心态。当然你可以有自己的写法，他们或许比我的更好，但是在这里我的意见就是：<br><strong>Be Positive and Always Believe that something good is gonna happen</strong><br><br><h3><b style="color: red">TIP3: 其他方面的努力</b></h3><br>与此同时，我也愿意分享一下自己其他方面所做的努力。放在最后是因为，比起额外的文书，这一项的普遍性和可适度更加的狭窄。<br><br>UC Berkeley官网上并没有渠道给wl学生提供补充材料（如论文abstract）或者推荐信材料。但是我依然没有放弃：在3，4月份，我寻找了高三一位比较赏识我的外教帮我写了一封额外的推荐信，内容中提到了我在申请季结束后保持的良好学习状态。然后，我将这封推荐信扫描为电子版，和我的财产证明（wl必须材料）放在了一起。<br><br>乍一看这或许是一个“耍小聪明”或者“利用规则”的操作。但实际上，假如招生官不承认这一封信，我并不会因此受到什么损失；反过来，很大可能性他们看到了这封信件并且饶有兴致的读了一番。虽然最后wl转正的决定性因素我无从得知，但正是这些小小的努力提高了成功的几率。<br><br>另外，我还寻找了能够找到的UCB校友资源，更好的了解了这所学校并且把我的理解加入了文书。最终的结果同样无法考量，但是我做出了努力。这就够了。<br><br><h3><b style="color: red">TIP4：我想说的</b></h3><br>其实我想传达的东西并不是这些技巧本身–毕竟不同的人会遇到不同的情况，你永远无法进行准确的预测。<br><br>但是，作为一名18岁的高三学生，有一些经验是可以从wl的努力中争取的，其中很多也将让你在大学申请以外的领域受益匪浅。比如我最开始提到的了解不同学校的转正率，这关乎我们在大数据的时代（当你轻点鼠标就可以得到信息）你对于信息的掌握以及tradeoff的判断。果断的放弃那些“不太可能”的学校并不是一种逃脱，而是为其他的wl申请提高几率。<br><br>而选定一所努力的学校之后，你要做的就是持之以恒的跟定这件事情，将你能控制的事情做到最好。相信事在人为，相信最好的结果–提交你的额外文书材料，然后静候佳音。<br><br>Waitlist的准备无论如何都是煎熬且不爽的。当其他人早早完成了高三的申请，开始了娱乐放飞自我，你仍然需要绷紧脑中的神经，寻找一切措施让自己在candidate pool中更加有竞争力。但是，当你完成了这一切，你的申请季将比其他人圆满，而你，也将懂得“善始善终”的奥义。<br><br>（这篇文章于5月初wl结果刚出动笔，一直到6.14日毕业晚会前夕完成，历经1个多月。其中我对于整个申请季过程有了很多新的回顾和思考。对于2023届的学弟学妹，wl的概念似乎还比较早，但是也不妨可以看看这篇文章提前的了解一下😄。）<br><br><h3><b style="color: Aqua">About Comment: 关于评论</b></h3><p>目前的评论系统是基于开源项目 <code>Gitment</code> 打造的，需要通过Github登陆授权才能进行阅读/发表评论/点赞的操作。这个有趣的项目利用Github Issues作为评论区，不失为一种很好的创意，各位有账号的可以试一试。<a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">Gitment项目地址</a></p>]]></content>
      
      
        <tags>
            
            <tag> 申请季 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AP最后复习-Several Sorting Methods in A Glance</title>
      <link href="/2018/05/15/AP%E6%9C%80%E5%90%8E%E5%A4%8D%E4%B9%A0-Several-Sorting-Methods-in-A-Glance/"/>
      <url>/2018/05/15/AP%E6%9C%80%E5%90%8E%E5%A4%8D%E4%B9%A0-Several-Sorting-Methods-in-A-Glance/</url>
      <content type="html"><![CDATA[<p>时间不多，下午就要考试了，基础的知识相信大家已经有掌握，那么最后可以临时抱佛脚的就是比较关键的 <strong>排序方法</strong> 了。下面给出AP最常考到的三种排序方法的代码实现，大家可以在看的同时想一想这三种方法的实现原理以及机制。</p><blockquote><br><b>PS：</b>代码实现是我昨晚默写一次过出来的。在保证实习机制核心原理不改变的情况下，代码的优化其实非常不足（比如一个值被 computed 多次而不是存储为变量）。所以看看排序就好。<br></blockquote><h2><font color="orange">I: 选择排序 Selection Sort</font></h2><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心在于一遍遍的找出第1，第2...第n小的数放在1,2...n位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = nums[i];</span><br><span class="line">        <span class="keyword">int</span> pos = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= min) &#123;</span><br><span class="line">                min = nums[j];</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[pos] = nums[i];</span><br><span class="line">        nums[i] = min;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2><font color="red">II: 冒泡排序 Bubble Sort</font></h2><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*难点在于双循环中两个循环一个向前一个向后。目的是每一轮循环将一个最小 值推到前面的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; i ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[j-<span class="number">1</span>] &gt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = nums[j-<span class="number">1</span>];</span><br><span class="line">                nums[j-<span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><h2><font color="green">III: 快速排序 Quick Sort</font></h2><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心在于将所有大于一个中心值（也就是pivot，一般取数组第一个）放到一边，小于它的放在另一边。每一次循环/递归的结果可以贡献给下一轮，所以效率高</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">int</span> j = end;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[start];</span><br><span class="line">    <span class="keyword">int</span> pos = start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt; pivot)</span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot)</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nums[start] = nums[j];</span><br><span class="line">    nums[j] = pivot;</span><br><span class="line"></span><br><span class="line">    quick_sort(nums, start, j - <span class="number">1</span>);</span><br><span class="line">    quick_sort(nums, j + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Merge Sort是没有时间写的…就记住Merge Sort使用了分而治之的方法（divide and conquer）然后逐个击破吧…</p>]]></content>
      
      
        <tags>
            
            <tag> Java APComputerScience </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AP CS复习（3）- 浅谈Java中的参数传递</title>
      <link href="/2018/04/26/java%E5%A4%8D%E4%B9%A03/"/>
      <url>/2018/04/26/java%E5%A4%8D%E4%B9%A03/</url>
      <content type="html"><![CDATA[<p>之前的 <code>ArrayList</code> 我已经做了一个视频放在了B站上面，其中完整提到了如何自己使用数组和泛型等技巧实现一个动态数组。<a href="https://www.bilibili.com/video/av22363824" target="_blank" rel="noopener">链接在这里，就不额外写博客了。</a></p><p>所以这篇博客讲的内容并不会是具体的一个类库，而是Java语言层面的有趣设定–<font color="red">参数传递的方法。</font>不同的编程语言在一些设定，比如 <code>GC</code>，<code>动/静态类型</code> , <code>传参方式</code> 上都有所不同。而掌握这些细节无论是对于程序的优化或是AP考试都有巨大的帮助。<br><a id="more"></a></p><font color="orange"><strong>我们先看看下面这个例子：</strong></font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    change(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = p;</span><br><span class="line">    p = q;</span><br><span class="line">    q = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明眼人都看得出这段代码的意图，即将a，b两个整形变量传入一个叫做change的方法当中，实现两个数的交换<strong>（这里先想一想，可以成功吗？）</strong>。</p><p>说明这段代码之前，先明确一下定义，which我们后面会经常提到：</p><ul><li><font color="red">实例参数（实参）：</font>调用方法时传入的参数，即a和b，在函数体外依然有用</li><li><font color="green">形式参数（形参）：</font>只能在函数内部使用的参数，即p和q，在函数结束后销毁（释放）</li></ul><p>我们可以轻易的看出，在上述代码调用方法 <code>change(a,b)</code> 时，实例参数a和b分别将3，4这两个整形值传递给了形式参数p和q。所以我们很肯定在这次调用的函数内部中，p=3并且q=4。<strong>但是问题来了。。。</strong></p><p><font color="blue"><strong>这样的参数传递究竟是以什么形式完成的呢？</strong></font></p><p><font color="red"></font><br>接下来，我们来考虑两种传参的典型情况：<strong>值传递和引用传递</strong>。</p><p></p><h3><b color="green">I：引用传递</b></h3><br>我们都知道，当我们在Java中为一个变量初始化并赋值的时候，有两个单独的步骤要走。<br><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/Parameters/para1.png" alt="本博客图片都为listar原创"><p></p><p><strong>如上图所示：</strong></p><ol><li>我们要创建一个int类型的变量a，这一步是初始化。</li><li>接着我们会在内存中存放一个值3，并且a引用了这个内存的地址。</li></ol><p>所以，当我们说 a=3 的时候，言下之意其实是变量a引用了内存中存储这个值。<br>那么，在我们进行参数传递时，<strong>假如（注意是假如）</strong>使用的是引用传递的方式，就会有这样的情况：<br><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/Parameters/para2.png" alt="本博客图片都为listar原创"><br>可以看到，由于形参p直接获得了a传递的引用（也就是3），而非另外在内存中创建（复制）一个值相同而地址不同的引用，<strong>a和p指向了同一个内存的地址</strong>。</p><p><font color="green"><strong>So what？</strong></font><br>那么显而易见的，如果在形参的函数体中对形参进行修改，<strong>那么影响到的将是“原数据”</strong>，毕竟这一个引用可是实参/形参共享的。如果是这种情况，最上面的 change() 的确能够实现目的。然而事实上，int 类型的参数传递遵循了下面要讲的“值传递”的方法。</p><p></p><h3><b color="green">II：值传递</b></h3><br><strong>我们来看下面这一张图：</strong><p></p><p><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/Parameters/para3.png" alt="本博客图片都为listar原创"><br>在值传递的情况下，实参a并非直接将其引用（图中红色的3）传递给形参p。<strong>反而，该引用被复制了一份，在内存中创造了一个地址不同但是值相同的新引用（途中绿色的3）并交付给了p</strong>。这就是所谓的值传递（只传值，不传引用）。</p><p><font color="green"><strong>So what？</strong></font><br>那么在这样的情况中，<strong>对形参进行修改是否会对实参有影响呢？</strong>答案肯定是否定的。因为a和p分别有不同的引用，相应的修改也只能作用在分别引用的范围内，例子如图：<br><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/Parameters/para4.png" alt="本博客图片都为listar原创"><br>p的值被修改为4，但是不影响实参a的值保持为3。在这种的情况下，<strong>最上面的change方法无法生效</strong>。这也是实际上 java 语言设定的情况。</p><p></p><h3><b color="green">III：小小总结</b></h3><br>说了这么多，那 Java 到底什么时候采用引用传递，什么时候采用值传递呢？总结如下：<p></p><p><strong>值传递：</strong>基本类型（int,short,boolean…）和他们的封装类，加上String<br><strong>引用传递:</strong> 其他的Object，包括基本类型的数组（int[], double[]）</p><p>最后给出一个引用传递的例子（传递 <code>char[]</code> 参数）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterExample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr);<span class="comment">//arr被改变，输出cbc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">char</span>[] arr)</span> </span>&#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="string">'c'</span>;<span class="comment">//由于char[]使用引用传递，这一变化会影响实参</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这也是为什么我们可以见到，在各种排序的算法当中，可以使用一个辅助的swap方法（需传入int[]以及交换的两个index）对整形数组进行改动了。</p><p>这是这个系列第3篇文章（不包括视频），简单讲解了两种不一样的传参方法。希望同学们对两种方法的不同有所了解，并熟悉他们在Java中的应用。</p>]]></content>
      
      
        <tags>
            
            <tag> Java APComputerScience </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个有趣的知乎问题实现</title>
      <link href="/2018/04/20/interesting-Zhihu-question/"/>
      <url>/2018/04/20/interesting-Zhihu-question/</url>
      <content type="html"><![CDATA[<p>前几天在知乎上看到了这样一个有趣的问题：</p><p><font color="blue"><strong>男友让我打十万个「对不起」，汉字标上多少遍。如何快速实现？</strong></font><br><strong>链接:</strong> <a href="https://www.zhihu.com/question/27229082/answer/369776555" target="_blank" rel="noopener">https://www.zhihu.com/question/27229082/answer/369776555</a><br><a id="more"></a><br>感觉挺有意思，毕竟题目要求“汉字标上”，所以是不能用下面这种简单的写法了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saySorry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10001</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"对不起,"</span> + i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上，题目的难点也就是在于如何把0到10000的阿拉伯数字（即 <code>int</code> )转化为中文数字表达（即 <code>String</code> )。在不借用外部类库的情况下，我自己用遍历的方法写出了一个可以表达 1 到 99999 中文表达的Java实现。由于iteration的方便性，我的实现目前来看比大多数知乎回答要更加精简。</p><h3><font color="green">I: Test Case</font></h3><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(num2Chinese(<span class="number">3</span>));</span><br><span class="line">    System.out.println(num2Chinese(<span class="number">30001</span>));</span><br><span class="line">    System.out.println(num2Chinese(<span class="number">10203</span>));</span><br><span class="line">    System.out.println(num2Chinese(<span class="number">39182</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">三</span><br><span class="line">三万零一</span><br><span class="line">一万零二百零三</span><br><span class="line">三万九千一百八十二</span><br></pre></td></tr></table></figure><br><br>可以看出，上述程序很好的实现了中文语义，包括数字后“万”，“千”等单位的添加以及“零”作为补足。那么我们下面就来看一下实现这样一个程序需要考虑的需求有哪些。<br><br><h3><font color="green">II: Requirements</font></h3><ol><li>对于每一数位，都需要将数位上的数字转化为 <code>中文数字+单位</code> 的形式。比如9325，那么千位上的 9 要变成“九千”，其中“九”为数字，“千”为单位。注意这一个需求在各位数的时候要忽略，毕竟上面例子中的 5 输出就为“五”而非“五一”。</li><li>如果数位中有 0 的存在，我们要分为两种情况，第一种就是在非0数字之间出现0。例如 9034，那么要做到的就是在“九千”后面加上一个“零”，然后继续输出“34”。注意就是输出0的时候不需要再输出数位的单位，这一点与 （1）冲突，所以在程序中会使用 <code>if - else</code> 的方式处理。</li><li><font color="red">然而上一点又有一个特殊情况!</font> 考虑这一个例子：90034。根据中文语义应该输出<strong>“九万零三十四”</strong>。看得出来，虽然中间有两个零（千位和百位)，但是实际输出只输出一个。那么程序中要做的就是判断在之前已经添加了一个“零”了，如果是则不继续添加。但如果两个零所在位置不连续，则两个零都要添加：比如 90203 应该输出<strong>“九万零二百零三”</strong>。所以我们会设定一个全局的 <code>boolean</code> 值，每次添加零都进行判断，在添加了零之后变为false，然后在添加不为零的数字后恢复位true。</li><li>继续第 (2) 点的另外一个情况。如果是在数字末尾的0，比如32000，那么我们会完全忽视掉（“三万二千”）。这种情况只需要判断数字z最后一位是否为 0 就可以了。程序中我们可以在循环的过程中按照 1-3 的规则先走，完全忽略第4点，最后在对要输出的字符串进行处理（删除掉末尾的“零”）。</li></ol><p> <strong>我们下面来看看源代码。</strong></p><p></p><h3><font color="green">III: Implementation</font></h3><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">printSorryWithChinese</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="string">"零"</span>);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">"一"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">"二"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">"三"</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">"四"</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">"五"</span>);</span><br><span class="line">        map.put(<span class="number">6</span>, <span class="string">"六"</span>);</span><br><span class="line">        map.put(<span class="number">7</span>, <span class="string">"七"</span>);</span><br><span class="line">        map.put(<span class="number">8</span>, <span class="string">"八"</span>);</span><br><span class="line">        map.put(<span class="number">9</span>, <span class="string">"九"</span>);</span><br><span class="line">        map.put(<span class="number">10</span>, <span class="string">"十"</span>);</span><br><span class="line">        map.put(<span class="number">100</span>, <span class="string">"百"</span>);</span><br><span class="line">        map.put(<span class="number">1000</span>, <span class="string">"千"</span>);</span><br><span class="line">        map.put(<span class="number">10000</span>, <span class="string">"万"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">num2Chinese</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">boolean</span> addZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> input = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">10000</span>; num &gt;=<span class="number">1</span>; num = num / <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = n / num;</span><br><span class="line">            <span class="keyword">if</span> (mod != <span class="number">0</span>) &#123;</span><br><span class="line">                buffer.append(map.get(mod));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (num != <span class="number">1</span>)</span><br><span class="line">                    buffer.append(map.get(num));</span><br><span class="line"></span><br><span class="line">                addZero = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length() != <span class="number">0</span> &amp;&amp; addZero &amp;&amp; num != <span class="number">1</span>) &#123;</span><br><span class="line">                buffer.append(map.get(<span class="number">0</span>));</span><br><span class="line">                addZero = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            n = n % num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((input+<span class="string">""</span>).endsWith(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> buffer.toString().substring(<span class="number">0</span>, buffer.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在上面讲完需求之后，具体的实现就很简单了。下面基于代码讲一下具体的思路：</p><p><font color="red"><strong>Step1:</strong></font> 创建并使用一个Map来承载数字=&gt;中文的映射关系<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个整型对应字符串的 key-value HashMap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="string">"零"</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"一"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"二"</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">"三"</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">"四"</span>);</span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">"五"</span>);</span><br><span class="line">    map.put(<span class="number">6</span>, <span class="string">"六"</span>);</span><br><span class="line">    map.put(<span class="number">7</span>, <span class="string">"七"</span>);</span><br><span class="line">    map.put(<span class="number">8</span>, <span class="string">"八"</span>);</span><br><span class="line">    map.put(<span class="number">9</span>, <span class="string">"九"</span>);</span><br><span class="line">    map.put(<span class="number">10</span>, <span class="string">"十"</span>);</span><br><span class="line">    map.put(<span class="number">100</span>, <span class="string">"百"</span>);</span><br><span class="line">    map.put(<span class="number">1000</span>, <span class="string">"千"</span>);</span><br><span class="line">    map.put(<span class="number">10000</span>, <span class="string">"万"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意使用 <code>static</code> 关键词的内容。这一代码段会在类加载阶段将内容注入到 map 中去。</p><p><font color="red"><strong>Step2:</strong></font> 声明变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个StringBuffer用于拼接字符串，在之前的文章中提过使用 “+” 运算符直接拼接速度很慢</span></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">//上文中提到的boolean值，用于判断是否可以添加零</span></span><br><span class="line"><span class="keyword">boolean</span> addZero = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//由于传入的参数int本身会在操作中被改变，所以需要提前用一个新的int承载其原本的值</span></span><br><span class="line"><span class="keyword">int</span> input = n;</span><br></pre></td></tr></table></figure></p><p><font color="red"><strong>Step3:</strong></font> 循环处理（从万位到个位）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从万位开始，每一次除以 10 降低一位，实现循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">10000</span>; num &gt;=<span class="number">1</span>; num = num / <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">//除以位数后的商即是该位数上的数字</span></span><br><span class="line">    <span class="keyword">int</span> mod = n / num;</span><br><span class="line">    <span class="comment">//商不等于0时，比如 90000/10000 = 9</span></span><br><span class="line">    <span class="keyword">if</span> (mod != <span class="number">0</span>) &#123;</span><br><span class="line">        buffer.append(map.get(mod));</span><br><span class="line">        <span class="comment">//上面说过，除了个位数，都要添加代表位数的单位</span></span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">1</span>)</span><br><span class="line">            buffer.append(map.get(num));</span><br><span class="line">        <span class="comment">//如果不是零的情况，要将boolean恢复为true（上面第三点）</span></span><br><span class="line">        addZero = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//商是零的情况，如 9000/10000 = 0</span></span><br><span class="line">    <span class="comment">//进行判断，要求添加的零不能作为返回字符串的开头，并且addZero允许添加零，而且位数不为各位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length() != <span class="number">0</span> &amp;&amp; addZero &amp;&amp; num != <span class="number">1</span>) &#123;</span><br><span class="line">        buffer.append(map.get(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//将addZero调回为false</span></span><br><span class="line">        addZero = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变n的值，判断下一位。如95320变为5320。</span></span><br><span class="line">    n = n % num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="red"><strong>Step4:</strong></font> 删除末尾的零<br>这一步很简单，看代码就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((input+<span class="string">""</span>).endsWith(<span class="string">"0"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.toString().substring(<span class="number">0</span>, buffer.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后返回字符串</span></span><br><span class="line"><span class="keyword">return</span> buffer.toString();</span><br></pre></td></tr></table></figure></p><p></p><h2><font color="green">最后总结：</font></h2><br>这个小程序是在AP CS课上无聊完成的。<br>对于这种逻辑相对复杂，要求繁琐的任务，知乎上很多的人直接使用了硬算的办法来解决。这样做的缺点是很大的，比如下次要扩展到一亿或者更大，要改动的地方就很多了。<br>反而，我们要先观察其中的规律，然后想想递归/遍历是否能够完成这一任务。最重要的是要将学会的设计模式运用在其中。<p></p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AP CS复习（2）- Math和Random基础</title>
      <link href="/2018/04/10/AP-CS%E5%A4%8D%E4%B9%A0%EF%BC%882%EF%BC%89-Math%E5%92%8CRandom%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/04/10/AP-CS%E5%A4%8D%E4%B9%A0%EF%BC%882%EF%BC%89-Math%E5%92%8CRandom%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>本来就不是什么高产的人，但是由于AP里面会有一些琐碎的小点，所以干脆简洁的介绍一下。今天讲的就是 <code>java.lang.math</code> 和 <code>java.util.Random</code> 这两个小点。这些方法大家应该都大致懂得使用，<strong>所以过一遍就好了</strong>。</p><a id="more"></a><hr><h2><font color="green">AP考什么?</font></h2><br>按照惯例，先上个传送门：<a href="http://media.collegeboard.com/digitalServices/pdf/ap/ap-computer-science-a-course-description.pdf" target="_blank" rel="noopener">College Board AP CS</a><br><br><strong><code>Java.lang.Math</code> 会考：</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">double</span> exponent)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br><br><strong><code>Java.util.Random</code> 会考（其实是FRQ会考）：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> nextInt(int bound);</span><br></pre></td></tr></table></figure><br><br>将这两个类放在一起讲主要是因为他都可以生成伪随机数字（伪随机会在后面重点提到）。<strong>这在回答一些AP FRQ时极为重要。</strong><br><br>&gt; <font color="blue">对于Math的类的其他方法，下面简略用实例一一演示</font><br><br><h3><font color="red">static int abs(int x / double x)</font></h3><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = -<span class="number">20</span>;</span><br><span class="line"><span class="comment">//返回int x的绝对值</span></span><br><span class="line"><span class="keyword">int</span> y = Math.abs(x); <span class="comment">// y = 20</span></span><br><span class="line"><span class="comment">//double 同理</span></span><br></pre></td></tr></table></figure><br><br>这个方法要自己实现也是非常之简单的，只需要通过if-else判断数字的正负然后一律改为正数就可以了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//source源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> -x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>没什么好说的。。。其实AP里面真正要考这个方法的也不多。<br><h3><font color="red">static double pow(double base, double exponent)</font></h3><br>Java中基本的operators很难做到十进制上的乘方操作。<br><strong>P.S. 在二进制层面是可以做到的，如移位运算符</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//表达式&lt;&lt; 3意味着将x的二进制表示向左平移3位，也就是乘以2^3</span></span><br><span class="line"><span class="comment">//原本：00011 -&gt; 对应十进制3</span></span><br><span class="line"><span class="comment">//改变：11000 -&gt; 对应十进制24</span></span><br><span class="line">x = x &lt;&lt; <span class="number">3</span>;</span><br><span class="line">System.out.println(x); <span class="comment">//结果为3*2^3=24</span></span><br></pre></td></tr></table></figure><br><br>但是通过递归或者遍历的方法，可以做到乘方的操作，这也是Math.pow()方法的实现基础（但事实上pow方法调用了C语言完成，并不是一个java本身方法）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算2^5</span></span><br><span class="line"><span class="comment">//虽然参数是double，可以直接传入int值，因为java中int可以被自动转型成double</span></span><br><span class="line"><span class="keyword">double</span> x = Math.pow(<span class="number">2.0</span>, <span class="number">5.0</span>);</span><br><span class="line">System.out.println(x); <span class="comment">//输出32.0</span></span><br></pre></td></tr></table></figure><br><br><strong>可以试着用递归的办法实现这个方法的简略版：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">powWithRecursion</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">double</span> expo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任何数零次方为1</span></span><br><span class="line">    <span class="keyword">if</span> (expo==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (expo==<span class="number">1</span>) <span class="keyword">return</span> base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> powWithRecursion(base, expo-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>分析一下上述方法，要求传入的expo必须是<strong><font color="green">positive integer</font></strong>（虽然写着是double），不然就会抛出 <code>StackOverFlowError</code> 。但至少，我们可以利用自己的知识实现一个高级的方法了。<br><br><br><h3><font color="red">static double sqrt(double x)</font></h3><br>顾名思义，这是一个求平方根的操作，在AP考试里考的也不多。要注意的是，当传入的参数为负时，不会抛出 <code>runtimeException</code> , 返回的结果却也并不是一般的double数字，而是一个静态常量NaN（not a number）。<br>在double类中，这个NaN是这样被定义的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NaN = <span class="number">0.0</span>d / <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><br><br>除了分母为0之外，更神奇的是，这个常量自己与自己不想等，<strong>可谓是六亲不认！</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = (Double.NaN == Double.NaN);</span><br><span class="line">System.out.println(b); <span class="comment">//false;</span></span><br><span class="line"><span class="comment">//所以唯一用于判断NaN的办法是Double.isNaN();</span></span><br></pre></td></tr></table></figure><br><br>在这个特例之外，sqrt方法就兢兢业业的返回输入数字的平方根，仅此而已了。<br><br><br>———-<br>在讲Random有关的方法之前，这里也稍作延伸，再简略补充几个Math类中的方法，并且讲一下使用它的注意事项。<br><strong>上代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">20</span>,<span class="number">30</span>); <span class="comment">//取最大数字30</span></span><br><span class="line">Math.min(<span class="number">20</span>,<span class="number">30</span>); <span class="comment">//取最小数字20</span></span><br><span class="line">Math.round(<span class="number">20.3</span>); <span class="comment">//四舍五入取20</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">//2.718...常量</span></span><br><span class="line"><span class="keyword">double</span> pie = Math.PI; <span class="comment">//3.14159...常量</span></span><br></pre></td></tr></table></figure><br><br>这里尤为注意的是最后两个静态常量值π和e，善于使用系统给定好的常量是java编程的一个非常好的习惯。这里顺带提一下<strong><font color="red">魔法值（magic number）</font></strong>的概念：<br><br><strong>代码实例1：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getCirclePerimeter</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6.28318</span>*radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这是一个通过输入半径计算圆周长的简单方法 <code>（C=2πr）</code> 。然而不认真看，你会惊讶：<strong>这个6.28318是哪里来的？这是什么鬼？</strong> 哦，想了好久才发现这是3.14159和2的乘积啊！这样的数字，既不是类的成员常量，在方法内部也没有local variable承载，<strong>就像是魔术师突然变出来的一样，给阅读代码的人增添很多麻烦！</strong><br><center><font color="red">所以这样的代码是要尽力避免的！</font></center><br><strong>代码实例2：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getCirclePerimeter</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*Math.PI*radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>是不是清晰明了多了？</strong> <code>Math.PI</code> 清晰，易读，即使不用注释也可以让阅读者轻松理解。何况Math类中的π的精准度极高，足够应付大多数计算场景。<br><br><br><br><br>———-<br><br><br><h3><font color="blue">Math类和异常</font></h3><br>这是第二个有趣且需要强调的点。我们来复习一遍：<br><br><strong>在Java中的Exception分为Checked和Unchecked两种</strong>，其中运行时异常 <code>（RuntimeException）</code> 属于 <code>unchecked exception</code>。并且，Java强制规定所有的 <code>checked exception</code> 都需要用某种方式处理（try/catch或者throws）。具体关于Java异常的知识AP不做过多要求，之后可能单独写博客总结。<br><br>显而易见，在Math类中很多情况我们要考虑参数所造成的异常（如负数开方/除0），而且这些异常在编译期间都是不会捕获的，只能等到 <code>runtime</code> 才能看得出来。这就是为什么比较有名的 <code>ArithmaticException</code> 是运行时异常的原因了，编译器也不会提醒你去捕获。<br><br>那么在写代码的时候（AP考试之外），就要自己留意参数了，不要想指望IDE来帮助你。<br><br><h2><font color="red">Random方法和伪随机</font></h2><br>我们先来看一下Math.random方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/没有参数</span></span><br><span class="line"><span class="comment">/返回一个在[0，1)之间的浮点值（左闭右开），如0.7762457478958932</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br><br><strong>看得出来，这个random出来的double值是很难直接使用的。</strong>一般来讲，如果要生成0到100之间的整数，我们可以这样做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于右边为开区间，故乘以100+1=101</span></span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>) (Math.random()*<span class="number">101</span>);</span><br></pre></td></tr></table></figure><br><br>上述操作先放大random值的倍数，然后转型为int。AP中有类似的考法，<strong>重点就在于理解其开闭区间的性质和放大的方法。</strong><br><br>相比之下，Random类的操作就更加方便。下面是Random类的两个构造函数，其中第二个我们会重点讲：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">Random random = <span class="keyword">new</span> Random(<span class="keyword">long</span> seed);</span><br></pre></td></tr></table></figure><br><br>使用上面，我们可以利用 <code>nextInt(int bound)</code> 方法得到随机数, <strong>返回一个0到bound-1之间的整数（也是左闭右开）。</strong><br><br>在AP考试中，有可能我们要设计一个这样的方法：<br><strong><font color="blue">一个盒子中有很多球（使用一个ArrayList装载），然后不放回的随机从中抽球。</font></strong><br><br>下面展示random在这个方法中的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">box</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Ball&gt; list;</span><br><span class="line">    <span class="comment">//构造方法中传入一个装有球的arraylist</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">box</span><span class="params">(ArrayList&lt;Ball&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保证不放回的取出球。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Ball <span class="title">pickBall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Ball pick = <span class="keyword">this</span>.list.remove(random.nextInt(list.length));</span><br><span class="line">        <span class="keyword">return</span> pick;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>上面pickBall方法里的一调用看懂了吧。通过巧妙的使用list.length作为生成随机数的上界，<strong>可以保证不会出现list取出球之后长度变短，进而导致</strong>   <code>indexOutOfBoundException</code>。<br><br><br>———-<br><br>最后的最后，稍微延伸一下，讲一下编程中的伪随机概念。我们先有趣的设计一个代码，其中我们使用了Random的第二个构造函数（传入一个long seed）:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Random ran1 = <span class="keyword">new</span> Random(<span class="number">100</span>);</span><br><span class="line">Random ran2 = <span class="keyword">new</span> Random(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"第一个随机的第"</span> +i+<span class="string">"个数字： "</span>+ran1.nextInt(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">"第二个随机的第"</span> +i+<span class="string">"个数字： "</span>+ran2.nextInt(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>结果令人震惊！！！</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第一个random的第<span class="number">0</span>个数字： <span class="number">5</span></span><br><span class="line">第二个random的第<span class="number">0</span>个数字： <span class="number">5</span></span><br><span class="line">第一个random的第<span class="number">1</span>个数字： <span class="number">0</span></span><br><span class="line">第二个random的第<span class="number">1</span>个数字： <span class="number">0</span></span><br><span class="line">第一个random的第<span class="number">2</span>个数字： <span class="number">4</span></span><br><span class="line">第二个random的第<span class="number">2</span>个数字： <span class="number">4</span></span><br><span class="line">第一个random的第<span class="number">3</span>个数字： <span class="number">8</span></span><br><span class="line">第二个random的第<span class="number">3</span>个数字： <span class="number">8</span></span><br><span class="line">第一个random的第<span class="number">4</span>个数字： <span class="number">1</span></span><br><span class="line">第二个random的第<span class="number">4</span>个数字： <span class="number">1</span></span><br></pre></td></tr></table></figure><br><br><strong>两个不同的random实例竟然每一次得到的随机数都是相同的？？？！！！</strong><br><br><br>———-<br>我们来思考一个问题：如果编程实现随机数是需要一个算法来计算的，那么：<br><h3><font color="red">“算法”和“随机”本身难道不是冲突的吗？？</font></h3><br>算法要求有特定的公式生成“随机”数字，那么掌握这个公式的人就可以知道随机生成的规律，那么随机也就不是随机了。<br><br>正式如此，像Random或者Math类这样的随机都是<strong>伪随机。</strong><br><br>事实上，<strong>java的伪随机实现是通过线性同余的方程实现的</strong>，基本公式如下：<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/5544515?fr=aladdin" target="_blank" rel="noopener">（百度百科）</a><br><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0=baike92,5,5,92,30/sign=f89cec91c1ef7609280691cd4fb4c8a9/50da81cb39dbb6fda60e0d2a0324ab18972b3761.jpg" alt="此处输入图片的描述"><br>简单来说，公式里的a，c和m都是整数常量，而随机数Xn+1的数值和上一个随机数Xn相关。那么第一个随机数和谁相关呢？哦，这时候上面代码里的long seed就有了意义了，这一个seed（种子）值就是用来确定第一个随机数用的。根据这个公式，种子数相等的两个random实例每一次随机出的数字都会是一样的（因为随机数只和上一个随机数有关）。<br><br><strong>但更要注意的是！！种子的值和随机出来的数字范围没有关系！</strong>虽然上面代码里的种子为100，但是nextInt产生的随机数范围还是在0和30之间的！<br><br>最后的问题是，刚刚代码里面，不带参数构造的random实例，也就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br></pre></td></tr></table></figure><br><br>它的种子又是什么呢？<strong>我们看一下源码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这个方法里面有二进制的运算符。但抛开这个不谈，我们发现了不带参的构造方法内部调用了带参的构造方法，而参数则于系统当前时间和一个叫 <code>seedUniquifier()</code> 方法的返回值相关。<br><br><strong>好了，最后我们讨论一下什么是</strong>“真随机”<strong>吧。</strong><br>既然算法本身无法得到真正的随机数，我们就要寻求计算机外界的帮助。虽然我对量子物理了解不多，但是我们不妨可以这样想：<br><br>既然量子世界中的一些值（如电子的运动）是不可预测的，我们可以通过观测读取这些值然后生成真随机数。<br><br>同理，现在也有以电脑硬件噪声大小（噪声大小在物理上可以看作随机的)作为输入得到随机值的办法。<br><br><h2><center>脑洞大开！！</center></h2><hr><p></p><h2><font color="green">写在最后</font></h2><br>这是本人的第二篇博文。不想只讲一下AP会考的无聊的方法，我在基础上进行延伸讨论了java随机数伪随机的问题和线性同余方程。<p></p><p>本人数学和CS水平都有限，但依然对这些AP不考，但是非常有趣的概念有着很大的热情。这一篇博文不太长，因为我在策划下一个知识点 <code>AP数据结构-数组和ArrayList</code> 的内容。<br>我计划做一个视频讲解list的API，并且带着大家通过泛型和数据结构自己实现一个ArrayList(很简单的啦！)，这个工作会在周末完成！</p><p>如果喜欢我的文章，不妨将它分享给你身边的CS学生或者对CS感兴趣的同学哦！</p>]]></content>
      
      
        <tags>
            
            <tag> Java APComputerScience </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AP CS复习（1）- String类及其API</title>
      <link href="/2018/04/08/AP%20CS%E5%A4%8D%E4%B9%A0%EF%BC%881%EF%BC%89-%20String%E7%B1%BB%E5%8F%8A%E5%85%B6API/"/>
      <url>/2018/04/08/AP%20CS%E5%A4%8D%E4%B9%A0%EF%BC%881%EF%BC%89-%20String%E7%B1%BB%E5%8F%8A%E5%85%B6API/</url>
      <content type="html"><![CDATA[<hr><p>很久之前就有开一个博客写文章的打算然而迟迟未能动笔。最近正好发现没有什么专门复习<font color="red">AP CS</font>的文章，所以就准备自己写一个。仔细想想，很多人会觉得<font color="red">AP CS</font>很水很弱智，所以我希望我写出的东西能够不只是应付AP本身，还要能够挖掘相对底层一点的东西（如某些方法的实现）。<br><strong>第一篇文章就从 <code>Java.lang.String</code> 这个概念讲起，大致概括AP的一些考点和一些额外的概念。</strong></p><h2 id="I-AP考什么"><a href="#I-AP考什么" class="headerlink" title="I: AP考什么?"></a><font color="green">I: AP考什么?</font></h2><p>先上一张图<em>（来自<a href="http://media.collegeboard.com/digitalServices/pdf/ap/ap-computer-science-a-course-description.pdf" target="_blank" rel="noopener">CB Course Description</a>）</em></p><a id="more"></a><p><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/String_01.png" alt="CB对于String类的要求"></p><p>可以看出，AP CS考试中对于String类的要求非常之低，除了通用的懂得如何实例化一个字符串之外，仅需要掌握5（其实是4）种方法就可以舒服的当一个api-caller了。<br>然而，除了懂怎么用之外，<strong>什么时候用</strong>则成为了一个更重要的问题。所以我们还是一个个方法逐一了解一下。</p><p></p><h3><font color="red">int length()</font></h3><br>不用多说，这个最简单的方法返回该字符串的长度。而这个方法常用于for循环中来遍历字符串中的字符。<p></p><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印出字符串"banana"中'a'字符的个数</span></span><br><span class="line">String str = <span class="string">"banana"</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.charAt(i) == <span class="string">'a'</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出为3</span></span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure><p>当然，这里可耻的使用了一个 <code>String.charAt(int index)</code> 的方法，但是不影响理解就好了。关于 <code>length()</code> 能讲的实在不多，毕竟它太基础了。</p><p><strong>稍微深入一点的话</strong>，不难发现String这个类其实是由一个char[]构成的。也就是说，一个”pig”这样的字符串本质上由’p’,’i’,’g’拼接而成。了解这一点，就不难发现String类有这样一个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] arr = &#123;<span class="string">'d'</span>,<span class="string">'o'</span>,<span class="string">'g'</span>&#125;;</span><br><span class="line"><span class="comment">//传入一个char[]作为参数</span></span><br><span class="line">String str = <span class="keyword">new</span> String(arr);</span><br><span class="line"><span class="comment">//输出"dog"</span></span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure></p><p>那么可想而知，<code>length()</code> 的底层实现也非常简单，就是返回char[]的length就可以了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String类中的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###<font color="red">substring(int from, int to)</font>###<br>下一个方法就是大名鼎鼎的 <code>substring</code> 方法。这个方法返回字符串中的一个子字符串，其上界和下界由参数中的from和to控制。为什么说这个方法很牛逼呢，其实是因为各种你想得到的方法都可以由 <code>substring</code> 方法得到。<br><strong>但在这之前，有两点需要注意！</strong></p><blockquote><p>对于给定的参数from和to，返回的子字符串是从 <code>charAt(from)</code> 开始到 <code>charAt(to-1)</code> 为止。换句话说，返回的子字符串的长度应该等于<code>to - from</code>,这样记就不会弄错啦！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"watermelon"</span>;</span><br><span class="line"><span class="comment">//0对应test中的'w'字符，而4却对应的是index为（4-1=3）的'e'字符。</span></span><br><span class="line"><span class="comment">//输出结果为"wate"</span></span><br><span class="line">System.out.println(test.substring(<span class="number">0</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>可想而知，这个方法常常用于截取字符串上，许多的AP FRQ问题都会考到。<br>但是，这里substring方法的用处可不止如此，我们可以通过操纵参数达到意想不到的效果。</p><p><strong>I：获取字符串的最后一个字符</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">//结果为o</span></span><br><span class="line">String lastChar = test.substring(test.length()-<span class="number">1</span>, test.length());</span><br><span class="line"><span class="comment">//上面也可以简写成（运用后面会讲的substring(int from)）</span></span><br><span class="line"><span class="comment">//String lastChar = test.substring(test.length()-1);</span></span><br></pre></td></tr></table></figure></p><p><strong>II: 究极脑经急转弯：如何不用遍历判断一个字符串是否由单一字符组成？</strong></p><p>直接上代码，这个能不能理解都无所谓，只是真的让人感叹substring的强大。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">consistOfSameChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//假设传入的str为"banana"</span></span><br><span class="line">    <span class="comment">//first = "banan" （除了最后一个字符）</span></span><br><span class="line">    String first = str.substring(<span class="number">0</span>, str.length-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//last = "anana" （除了第一个字符）</span></span><br><span class="line">    String last = str.substring(<span class="number">1</span>, str.length());</span><br><span class="line">    <span class="comment">//判断他们是否相等即可判断该字符串是否由同一字符组成</span></span><br><span class="line">    <span class="keyword">return</span> first.equals(last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，简单提一下 <code>substring(int from)</code> 这个方法，作为前一个方法的重写，这个方法更加的方便，直接返回从给定的index from到字符串末尾的子字符串。本质上:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.substring(<span class="keyword">int</span> from) 和 x.substring(<span class="keyword">int</span> from, x.length()) 相同</span><br></pre></td></tr></table></figure></p><p></p><h3><font color="red">int indexOf()</font></h3><br><strong>又是一个强大的方法！</strong>！<br>本质上idnexOf方法在String类中被复写了4遍。但操蛋又温柔的CB爸爸只要求考其中的一种，即参数为String的那种。<p></p><blockquote><font color="blue">Talk is cheap, show me the code – Linus</font></blockquote><p>我们废话少说，直接上一个清晰易懂的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被匹配的字符串</span></span><br><span class="line">String test = <span class="string">"listar2000"</span>;</span><br><span class="line"><span class="comment">//想要查找的值</span></span><br><span class="line">String match1 = <span class="string">"star"</span>;</span><br><span class="line"><span class="comment">//得出位置1</span></span><br><span class="line"><span class="keyword">int</span> position1 = test.indexOf(match1);</span><br><span class="line"><span class="comment">//输出结果为2，也就是说，首先listar2000中包含star这个子字符串，同时star中的第一个字符s在listar2000中的位置为2，所以返回一个int值=2。</span></span><br><span class="line">System.out.println(position);</span><br><span class="line"><span class="comment">//下面我们再看另一种情况</span></span><br><span class="line">String match2 = <span class="string">"michael"</span>;</span><br><span class="line"><span class="comment">//欸，明明listar2000里面不包含michael啊，怎么办呢?</span></span><br><span class="line"><span class="keyword">int</span> position2 = test.indexOf(match2);</span><br><span class="line"><span class="comment">//int值在字符串中不包含的情况下返回-1</span></span><br><span class="line">System.out.println(position2);</span><br></pre></td></tr></table></figure></p><p>言简意赅，雷厉风行。如果有，返回子字符串的起始位置；如果没有，返回-1。清晰明了。这样也可以看出，indexOf这个方法可以用来做匹配，查询字符串中是否包含某个段落。下面是最近CS Project里面的一段真实代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串中是否含有某个子字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSubstring</span><span class="params">(String str, String match)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.indexOf(match)&gt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，其实String类的API中早就已经预设好类似 <code>contains</code> 这样的方法直接返回一个boolean告诉你字符串是否包含。但是灵活掌握一种方法同时融会贯通的能力也是非常重要的。另一方面，这里也想着重强调官方文档的重要性，多看文档，会发现很多方法早就预设在jdk里面，<strong>不需要像我刚刚一样重复造轮子</strong>，非常麻烦! <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" target="_blank" rel="noopener">传送门</a></p><p></p><h3><font color="red">int compareTo()</font></h3><br>最后一个方法稍微有点复杂，所以我们从其源码的implementation角度来理解这个方法的具体功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到自身和同自身比较的字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="comment">//得到两字符串较短的长度的值，如一个长为5，一个为3，则取3。</span></span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="comment">//得到两字符串分别的char[]，刚刚提过这是内置在String类中的成员变量</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">    <span class="comment">//下面开始注意!!</span></span><br><span class="line">    <span class="comment">//从两个字符串的第一个字符开始遍历，到刚刚得到的最短长度为止</span></span><br><span class="line">    <span class="comment">//将每一个index的字符进行比较，如果不相同则返回c1 - c2的差</span></span><br><span class="line">    <span class="comment">//注意，java中char类型的差为ASC-II码表上对应的值。比如A的值为65，a     的值却是97，那么'a'-'A'就等于32.</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在0到lim范围内两字符串的字符都相同，那么返回的int值不再是ASC-II码表编号的差距，而是直接两字符串长度的差！！</span></span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>会发现十分操蛋的一点是，compareTo返回的int值，根据比较的两个字符串的不同，返回时的判定方式也不一样。<strong>要着重记住的点就是，java中char类型比较的是其ASC-II码表的编号差！！</strong></p><p><strong><font color="red">算了，看完了底层实现，我们看一下实例来说明问题吧！</font></strong></p><p><strong>例子1：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"applegood"</span>;</span><br><span class="line">String b = <span class="string">"Apple"</span>;</span><br><span class="line">System.out.println(a.compareTo(b));</span><br><span class="line"><span class="comment">//输出为32</span></span><br></pre></td></tr></table></figure></p><ol><li>执行compareTo方法</li><li>从第一个字符开始遍历，找不同。</li><li>发现第一个字符’a’和’A’就不一样</li><li>根据ASC-II码表，分别找出a（97）和A（65）的编号。</li><li>返回97-65=32.</li></ol><p><strong>例子2：</strong><br>这次只改变了一个字符的大小写，结果截然不同啊！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"applegood"</span>;</span><br><span class="line">String b = <span class="string">"apple"</span>;</span><br><span class="line">System.out.println(a.compareTo(b));</span><br><span class="line"><span class="comment">//输出为4</span></span><br></pre></td></tr></table></figure></p><ol><li>执行compareTo方法</li><li>从第一个字符开始遍历，找不同。</li><li>发现找到apple的末尾，也就是index=4还是一样！</li><li>不干了，直接返回两个字符串长度差，也就是4</li></ol><p><b><font color="red">这到底是什么JB玩意？!</font></b><br><b><font color="red">Java就这样implement的？？？</font></b></p><blockquote><font color="blue">PHP is the best programming language in the world!!<br>Life is short, I use Python!!</font></blockquote><p>好吧说了这么多，反正AP也不会考这么深。但是着<strong>再一次的证明了阅读源码的重要性啊</strong>！！！不然鬼知道这个int返回值是什么东西。只要记住当 <code>compareTo</code> 返回的是0时，那么这两个字符串就是相等了。不过话说用equals不是更好么。。。</p><p></p><h3><font color="red">Beyond AP：来看看String类的魔性设定</font></h3><br>首先我们看一下String这个类中源码的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p>抛开implements的那一大串接口不谈，你会发现一个恐怖的字眼 <code>final class</code><br>更恐怖的是，<strong>作为String根本的成员变量char[]（之前提过），也是final修饰的。</strong>这也意味着，String这个对象本身其实是不可改变的。</p><p>有人马上会说，胡说八道！字符串的拼接是怎么实现的？<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"star"</span>;</span><br><span class="line">test = test + <span class="string">"is handsome"</span>;</span><br></pre></td></tr></table></figure></p><p><strong>这不是改变了吗？</strong><br>但其实，在我们每一次的进行字符串拼接的时候，其实Java底层都是创建了一个新的String对象来承载新的字符串。不信，可以用hashcode()方法测验一下(一般我们认为hashcode相同的两个object指向内存中的同一对象)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"star"</span>;</span><br><span class="line"><span class="comment">//3540562</span></span><br><span class="line">System.out.println(test.hashCode());</span><br><span class="line">test = test + <span class="string">"is handsome"</span>;</span><br><span class="line"><span class="comment">//-632481145</span></span><br><span class="line">System.out.println(test.hashCode());</span><br></pre></td></tr></table></figure></p><p>很明显的，对象改变了。事实上，针对String的hashcode有一个特殊的算法，保证内容相同的字符串拥有相同的hashcode。我们使用拼接改变字符串，自然让hashcode同样有了变化。<br><b><font color="blue">这就带来了一个问题!!</font></b><br>当我们的程序需要频繁的拼接字符串的时候，性能会由于频繁的new对象受到影响。而在Java这一成熟的语言中，要解决这个问题也是非常简单的。既然String是一个不可变的类，那么就用辅助的可变类来帮助进行频繁的拼接操作。如：StringBuffer和StringBuilder。</p><p>下面直接上一篇<a href="https://www.cnblogs.com/Faith-zhang/p/6374834.html" target="_blank" rel="noopener">其他人博客</a>的实验结果：</p><blockquote><p>用String+=拼接字符串的时间27468<br>用String=String+拼接字符串的时间25813<br>用String.concat拼接字符串的时间12265<br>用StringBuffer.append拼接字符串的时间14<br>用StringBuilder.append拼接字符串的时间8 </p></blockquote><p>效果立杆见影，可想而知了吧。。。<br>具体的使用方法这里不多谈，希望大家可以查阅官方文档来获取资讯。</p><hr><p></p><h2><font color="blue">最后</font></h2><br>第一篇博文是有点试试水的心态写的，如有疏漏请多原谅。本文借鉴了少数他人博客和大量官方文档，但最多的还是自己开着IDE进行测试。这里也鼓励各位多多肝码，自己尝试。<br>AP不到一个月了，作为Senior我觉得有时间可以写一下这方面的博客来帮助大家复习。同时，自己的Hexo博客刚开所以没有怎么设置，目前应该是没有留言功能的。所以大家想了解AP CS中的哪方面知识可以微信找我。就这样了！！<p></p>]]></content>
      
      
        <tags>
            
            <tag> Java APComputerScience </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>My First Blog Post!</title>
      <link href="/2018/04/07/My-First-Blog-Post/"/>
      <url>/2018/04/07/My-First-Blog-Post/</url>
      <content type="html"><![CDATA[<p><strong>大家好！！！</strong></p><p>很早之前就想开一个自己的博客来写一些编程/学习/日常的东西。<br>首先考虑了用[CSDN][1]/[简书][2]等平台。然而一想：这也太不Geek了吧。。所以在CSDN上写了几篇sb Java技术文章之后就没有继续了。。</p><p>之后由于学了一些Java Web的技术，就想要自己从前端到后端写一个博客出来（无非就是 <code>JSP + Servlet + MySQL + JavaBean</code> 这一套，连框架都没用）。结果发现自己前端水平实在底下，然后 <code>Java Web</code> 的部署真的是捉急。所以也放弃了。</p><p>最后所以还是选择Hexo这样的博客框架，然后配合Github的免费域名凑合来建博客。<strong>Markdown</strong>现在用的也不好，唉，就这样咯。</p><p><strong>接下来会发布一些技术文章吧。。。或许。。。可能吧</strong></p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/07/hello-world/"/>
      <url>/2018/04/07/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
