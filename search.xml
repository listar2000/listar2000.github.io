<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>我也曾是那般狂妄的少年</title>
      <link href="/2018/05/30/%E7%8B%82%E5%A6%84%E7%9A%84%E6%88%91/"/>
      <url>/2018/05/30/%E7%8B%82%E5%A6%84%E7%9A%84%E6%88%91/</url>
      <content type="html"><![CDATA[<p>沉静在<strong>Diss他人</strong>快感中的人，又是否想过<font color="red"> <strong>被群起而攻之</strong> </font>时自己狼狈不堪的下场呢？</p><p><img src="https://raw.githubusercontent.com/listar2000/listar2000.github.io/master/post_images/crazy_boy/%E9%94%AE%E7%9B%98%E4%BE%A0.jpg" alt="Keyboard Man"></p><p>今天下午看到了那个闹得沸沸扬扬的知乎回答时，我毫不犹豫的完成了一次漂亮的“反对”+“没有帮助”+“举报”三连。我没有到评论区理论或者骂人，因为我竟然在这位匿名学弟（or学妹，暂且算作学弟）的行文中看到了自己曾经的影子，也看到了那些我曾经做过而现在却后悔莫及的事。</p><p>后来这位同学的回答愈来愈稀奇古怪，什么“Lofter”上看的，什么“不是HFI的”等等自相矛盾的话语接踵而至。我想他恐怕也是心神不安的吧。知乎的匿名答题机制是他最后一道保护罩；他估计也不知道自己会不会被识破，以及识破后的后果如何吧。</p><p>我希望这个答案能被举报，因为我不希望流言蜚语被大肆传播，同时也希望能给这个不成熟的同学一个台阶下（在他依然固执的情况下）。<strong>毕竟，我也曾是那般狂妄的少年。</strong></p><font color="green"><strong>时间回到高一暑假…</strong></font><p>那时，我在金融社风头正盛，参加完几次商赛后变得有点不可一世，基本上就是感觉谁都是辣鸡那种。</p><p>我在暑假期间以学指身份参加了广州几所国际学校联合举办的一个商赛（下以P商赛代称）。心高气盛的我带领着一支HFI金融社的学指队伍，渴望“征服”珠江之滨。</p><p>回过头看，那几天商赛的进程可以算是顺利。虽然有些许摩擦和中断，但至少整个系统还是在有条不紊的进行着。可对于当时的我，很多再平常不过的失误都可以成为大肆批评一番的对象。我批评着，嘲讽着P商赛的种种不足–毕竟他们和理想主义的我的心中那种“高大上”的比赛有着太大的差距；最牛逼的地方在于，我在商赛最后一天洋洋洒洒的写出一篇自认为的大作–<font color="red"><strong>《P商赛的失败给我们的教训》</strong></font>，并在金融社内大肆传播。</p><p>可能我当时比这个匿名同学还要吊上许多吧，毕竟这篇大作的开头可是有“李思达”三个20号字体镇楼的。</p><p>后来呢，相信很多金融社的同学都知道，这篇文章被某位社员“不小心”泄露到多所学校的商赛交流群内，轰动一时。当时的金融社社长唐臣可以说为了帮我擦屁股忙的焦头烂额，那位社员也不得不道歉息事宁人。</p><p>而我呢？我不得不考虑我从没想过的一个问题：<strong>Diss完别人之后被发现咋办？</strong> 那段时间，我几乎删掉了所有和外校有联系的商赛微信群，无时无刻不在想着怎么给出合理的解释。我相信此时此刻那位匿名同学也能够分享我当时的心境吧。</p><p>我更想说的是，很多我狂妄的，自以为是的言论，都只是自己幼稚和极端理想主义的体现，也就是所谓的未经世事。再后来我当上社长之后，我真正了解到办好一个商赛需要付出多少的时间来准备和调试，知道想要避免所有的错误基本上就是无稽之谈。<strong>我明白很多时候比起过分追求细节的完美，能够完整顺利的控制整个商赛的大局更加难能可贵。</strong></p><p>我发现了P商赛那么多的好，可当初满目都是它的坏。</p><p>我后悔，却又后悔莫及。我丧失了那几所学校对HFI金融社起码的信任，这给我宣传自己商赛的时候带来巨大的难题；我和那次商赛的负责人–一位之前认识多年的老友–失去了联络；本来我可以向他请教，取经，但这一切都因为我的狂妄和傲慢而白白葬送。</p><p>我想这位匿名同学犯了和我一样同样的错误：</p><p>他以为，或者说要求，上剑桥，CMU，JHU的学长学姐都是完美无瑕的圣人，在感情方面不能移情别恋，否则就是“婊子”或“狗“。一见钟情或者坚守一生的确难能可贵，但难道寻找一段新的恋情就低人一等吗？</p><p>同样的，他认为所谓优秀学校的学生就不能在他逻辑不通时骂人，否则就是“没有素质”，全然不顾很多评论都是在讲道理和说逻辑。勇于发声和反对垃圾不实谣言和消息，是我们HFI学生扎根于血统中的精神，我为他们感到骄傲。</p><p>匿名的这位同学啊，请恕我引用《心灵捕手》中的台词劝告你，同时题型自己</p><p><strong>“你只是个孩子，你根本不晓得你在说什么。问你艺术，你可能会提出艺术书籍中的粗浅论调，有关米开朗基罗，你知道很多，他的满腔政治热情，他与教皇相交莫逆，和他的耽于性爱，你对他很清楚吧？但你知道西斯汀教堂的气味吗？你没试过站在那儿，昂首眺望天花板上的名画吧？你肯定未见过吧？ 如果我问关于女人的事，你大可以向我如数家珍，你可能上过几次床，但你没法说出在女人身旁醒来时，那份内心真正的喜悦。你年轻彪悍，我如果和你谈论战争，你大可以会向我大抛莎士比亚，背诵“共赴战场，亲爱的朋友“，但你从未亲临战阵，未试过把挚友的头拥入怀里，看着他吸着最后一口气，凝望着你，向你求助。我问你何为爱情，你可能会吟风弄月，但你未试过全情投入真心倾倒”</strong></p><p>如果你真的是一个junior学生，希望你在经历过申请季的喜怒哀乐，经历一段意义非凡的恋情后，重新回过头来审视自己回答中的“感情观”和各种观。</p><p>然后，希望你能够删除掉知乎上的答案，说一句道歉。</p><p>这并不可耻，毕竟，我也曾是那般狂妄的少年。</p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>心态，信心，与战略：wl转正终极攻略</title>
      <link href="/2018/05/17/%E7%BE%8E%E6%9C%AC%E7%94%B3%E8%AF%B7wl%E8%BD%AC%E6%AD%A3%E6%94%BB%E7%95%A5/"/>
      <url>/2018/05/17/%E7%BE%8E%E6%9C%AC%E7%94%B3%E8%AF%B7wl%E8%BD%AC%E6%AD%A3%E6%94%BB%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>笔者自己的2018 Fall美本申请在前几天刚刚落下帷幕。本应该早在四月初收尾的申请季，由于一封waitlist的存在被强行延长了一月。而幸运的是，我在这一个月内为这封wl的奔波和努力最终都有了成效–我最终如愿以偿的被 <code>UC Berkeley</code> 录取。在号称“最难申请季”的今年，能以伯克利收尾，我已经非常满意。这里也想分享诸多wl转正的攻略以供学弟学妹参考。</p><a id="more"></a><font color="red"></font><br><b>注：</b>延迟录取在非常多的情况下属于<b>“courtesy waitlist”</b>，也就是说最终转正的几率非常的小。<font color="red">这篇文章会讲述如何最大化转正的可能，但是最终结果还是有很多运气的成分！</font><p></p><h2><font color="green">1. 心态很重要</font></h2><br>你点开录取结果，发现屏幕上没有出现期待已久的彩带 or 烟花特效。稍微了解web前端原理的你或许F12点开了控制台，想看一看CSS文件是否加载失败。一连串清晰的“200”状态码残酷的告诉你网络传输并没有问题。接着，你带着不安的心情匆匆扫过前几行文字，那个期盼已久的”congratulations”迟迟没有到来，只留下敷衍的“the result of your application doesn’t reflect your ability”。<p></p><p><strong>“噢，我被reject了！”</strong></p><p>这时候，你往往沉浸在没有被录取的悲伤之中，却无心去留意自己到底是被拒绝还是收到了waitlist（至少我在ED宾大的时候就错把defer当成了reject）。振作起来！如果你收到了waitlist，就代表着这个学校的招生办（至少对于大部分学校）对于你有着这两种印象：</p><ol><li><strong>这个学生不错</strong>，申请材料各方面没有明显的短板，但是由于 qualified students 太多 (或者留给国际生学位不够），还是放在wl里面等着先吧。</li><li><strong>这个学生还可以，但是没达到进入我们学校的标准</strong>。为了给他留个不差的印象，给个wl安慰一下吧（也就是所谓的 courtesy waitlist）。</li></ol><p>作为不幸中的万幸，大家肯定都期待着第一种情况。对于第二种情况，不仅和直接翠拒无异，而且还会浪费同学们大量的时间和精力去写一些毫无意义的love letter和emails。</p><font color="blue">那么，到底如何分清第一种和第二种waitlist呢？</font><p>最好的办法便是查看这所学校往年的 <strong>wl转正率</strong>。</p><h3><b style="color: red">TIP1: 查看学校往年WL转正率</b></h3><p>我们先看一下大体的情况：</p><p><img src="https://raw.githubusercontent.com/listar2000/listar2000.github.io/master/post_images/wl%E8%BD%AC%E6%AD%A3%E6%8C%87%E5%8D%97/%E8%BD%AC%E6%AD%A3%E7%8E%87.jpeg" alt="此处输入图片的描述"></p><p><strong>从上图可以看到</strong>，大多数的大学其实都在发放所谓的 courtesy waitlist。2016年的数据表明，wl转正的平均概率是18%，而大多数大学的转正率都在10%之下。<br><strong>但另一方面</strong>，仍然有16%的学校转正率在40%以上（其中包括了一些有名的加州大学），意味着被这些学校wl的学生有很大几率可以最终转正。</p><p>详细来讲，截取 <a href="http://www.sohu.com/a/136193436_322995" target="_blank" rel="noopener">搜狐教育</a> 的文章数据，几所知名大学2016年的wl数据如下：<br>| 学校 | wl转正人数 | 转正率 |<br>| - | - | - |<br>| Amherst | 3 | 1% |<br>| Boston College | 112 | 4% |<br>| Case Western | 333 | 7% |<br>| Cornell | 61 | 2% |<br>| Dartmouth | 16 | 1% |<br>| UC Berkeley | 1340 | 55% |<br>| UC Davis | 2571 | 83% |</p><p><strong>其中可以看出：</strong><br>假如你被康奈尔或者达特茅斯之藤校 wl，就告诉自己被拒了吧。各位数的转正率可是比申请时的录取率还低了几个档次的。<br>然而，假如你像我一样，被UCB或者UCD给wl了，那么请好好的准备–不乱玩的话，Offer在不远处等你。</p><p>这同时也告诉我们，<strong>如果同时被多所学校waitlist，一定要做好足够调查，分清主次，然后适当的accept wl并准备后续的工作</strong>。</p><blockquote><p><b style="color: maroon">个人经验:</b><br>我在申请阶段同时收到了 UCB, Emory, 以及WUSTL的waitlist。而在分析之后，发现除了伯克利之外的学校转正几率非常之低。所以最后决定只接受UCB的wl并且全力准备后续的材料。</p></blockquote><p>做好了这一步之后, make your choice &amp; keep running forward。下一步就是后续材料的准备了。</p><p>//TO BE CONTINUED 2018.5.19</p>]]></content>
      
      
        <tags>
            
            <tag> 申请季 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AP最后复习-Several Sorting Methods in A Glance</title>
      <link href="/2018/05/15/AP%E6%9C%80%E5%90%8E%E5%A4%8D%E4%B9%A0-Several-Sorting-Methods-in-A-Glance/"/>
      <url>/2018/05/15/AP%E6%9C%80%E5%90%8E%E5%A4%8D%E4%B9%A0-Several-Sorting-Methods-in-A-Glance/</url>
      <content type="html"><![CDATA[<p>时间不多，下午就要考试了，基础的知识相信大家已经有掌握，那么最后可以临时抱佛脚的就是比较关键的 <strong>排序方法</strong> 了。下面给出AP最常考到的三种排序方法的代码实现，大家可以在看的同时想一想这三种方法的实现原理以及机制。</p><blockquote><br><b>PS：</b>代码实现是我昨晚默写一次过出来的。在保证实习机制核心原理不改变的情况下，代码的优化其实非常不足（比如一个值被 computed 多次而不是存储为变量）。所以看看排序就好。<br></blockquote><h2><font color="orange">I: 选择排序 Selection Sort</font></h2><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心在于一遍遍的找出第1，第2...第n小的数放在1,2...n位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = nums[i];</span><br><span class="line">        <span class="keyword">int</span> pos = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt;= min) &#123;</span><br><span class="line">                min = nums[j];</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[pos] = nums[i];</span><br><span class="line">        nums[i] = min;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2><font color="red">II: 冒泡排序 Bubble Sort</font></h2><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*难点在于双循环中两个循环一个向前一个向后。目的是每一轮循环将一个最小 值推到前面的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; i ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[j-<span class="number">1</span>] &gt; nums[j])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = nums[j-<span class="number">1</span>];</span><br><span class="line">                nums[j-<span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p></p><h2><font color="green">III: 快速排序 Quick Sort</font></h2><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心在于将所有大于一个中心值（也就是pivot，一般取数组第一个）放到一边，小于它的放在另一边。每一次循环/递归的结果可以贡献给下一轮，所以效率高</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">int</span> j = end;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[start];</span><br><span class="line">    <span class="keyword">int</span> pos = start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt; pivot)</span><br><span class="line">            j--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= pivot)</span><br><span class="line">            i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nums[start] = nums[j];</span><br><span class="line">    nums[j] = pivot;</span><br><span class="line"></span><br><span class="line">    quick_sort(nums, start, j - <span class="number">1</span>);</span><br><span class="line">    quick_sort(nums, j + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>Merge Sort是没有时间写的…就记住Merge Sort使用了分而治之的方法（divide and conquer）然后逐个击破吧…</p>]]></content>
      
      
        <tags>
            
            <tag> Java APComputerScience </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AP CS复习（3）- 浅谈Java中的参数传递</title>
      <link href="/2018/04/26/java%E5%A4%8D%E4%B9%A03/"/>
      <url>/2018/04/26/java%E5%A4%8D%E4%B9%A03/</url>
      <content type="html"><![CDATA[<p>之前的 <code>ArrayList</code> 我已经做了一个视频放在了B站上面，其中完整提到了如何自己使用数组和泛型等技巧实现一个动态数组。<a href="https://www.bilibili.com/video/av22363824" target="_blank" rel="noopener">链接在这里，就不额外写博客了。</a></p><p>所以这篇博客讲的内容并不会是具体的一个类库，而是Java语言层面的有趣设定–<font color="red">参数传递的方法。</font>不同的编程语言在一些设定，比如 <code>GC</code>，<code>动/静态类型</code> , <code>传参方式</code> 上都有所不同。而掌握这些细节无论是对于程序的优化或是AP考试都有巨大的帮助。<br><a id="more"></a></p><font color="orange"><strong>我们先看看下面这个例子：</strong></font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    change(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = p;</span><br><span class="line">    p = q;</span><br><span class="line">    q = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明眼人都看得出这段代码的意图，即将a，b两个整形变量传入一个叫做change的方法当中，实现两个数的交换<strong>（这里先想一想，可以成功吗？）</strong>。</p><p>说明这段代码之前，先明确一下定义，which我们后面会经常提到：</p><ul><li><font color="red">实例参数（实参）：</font>调用方法时传入的参数，即a和b，在函数体外依然有用</li><li><font color="green">形式参数（形参）：</font>只能在函数内部使用的参数，即p和q，在函数结束后销毁（释放）</li></ul><p>我们可以轻易的看出，在上述代码调用方法 <code>change(a,b)</code> 时，实例参数a和b分别将3，4这两个整形值传递给了形式参数p和q。所以我们很肯定在这次调用的函数内部中，p=3并且q=4。<strong>但是问题来了。。。</strong></p><p><font color="blue"><strong>这样的参数传递究竟是以什么形式完成的呢？</strong></font></p><p><font color="red"></font><br>接下来，我们来考虑两种传参的典型情况：<strong>值传递和引用传递</strong>。</p><p></p><h3><b color="green">I：引用传递</b></h3><br>我们都知道，当我们在Java中为一个变量初始化并赋值的时候，有两个单独的步骤要走。<br><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/Parameters/para1.png" alt="本博客图片都为listar原创"><p></p><p><strong>如上图所示：</strong></p><ol><li>我们要创建一个int类型的变量a，这一步是初始化。</li><li>接着我们会在内存中存放一个值3，并且a引用了这个内存的地址。</li></ol><p>所以，当我们说 a=3 的时候，言下之意其实是变量a引用了内存中存储这个值。<br>那么，在我们进行参数传递时，<strong>假如（注意是假如）</strong>使用的是引用传递的方式，就会有这样的情况：<br><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/Parameters/para2.png" alt="本博客图片都为listar原创"><br>可以看到，由于形参p直接获得了a传递的引用（也就是3），而非另外在内存中创建（复制）一个值相同而地址不同的引用，<strong>a和p指向了同一个内存的地址</strong>。</p><p><font color="green"><strong>So what？</strong></font><br>那么显而易见的，如果在形参的函数体中对形参进行修改，<strong>那么影响到的将是“原数据”</strong>，毕竟这一个引用可是实参/形参共享的。如果是这种情况，最上面的 change() 的确能够实现目的。然而事实上，int 类型的参数传递遵循了下面要讲的“值传递”的方法。</p><p></p><h3><b color="green">II：值传递</b></h3><br><strong>我们来看下面这一张图：</strong><p></p><p><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/Parameters/para3.png" alt="本博客图片都为listar原创"><br>在值传递的情况下，实参a并非直接将其引用（图中红色的3）传递给形参p。<strong>反而，该引用被复制了一份，在内存中创造了一个地址不同但是值相同的新引用（途中绿色的3）并交付给了p</strong>。这就是所谓的值传递（只传值，不传引用）。</p><p><font color="green"><strong>So what？</strong></font><br>那么在这样的情况中，<strong>对形参进行修改是否会对实参有影响呢？</strong>答案肯定是否定的。因为a和p分别有不同的引用，相应的修改也只能作用在分别引用的范围内，例子如图：<br><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/Parameters/para4.png" alt="本博客图片都为listar原创"><br>p的值被修改为4，但是不影响实参a的值保持为3。在这种的情况下，<strong>最上面的change方法无法生效</strong>。这也是实际上 java 语言设定的情况。</p><p></p><h3><b color="green">III：小小总结</b></h3><br>说了这么多，那 Java 到底什么时候采用引用传递，什么时候采用值传递呢？总结如下：<p></p><p><strong>值传递：</strong>基本类型（int,short,boolean…）和他们的封装类，加上String<br><strong>引用传递:</strong> 其他的Object，包括基本类型的数组（int[], double[]）</p><p>最后给出一个引用传递的例子（传递 <code>char[]</code> 参数）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterExample</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">        change(arr);</span><br><span class="line">        System.out.println(arr);<span class="comment">//arr被改变，输出cbc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">char</span>[] arr)</span> </span>&#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="string">'c'</span>;<span class="comment">//由于char[]使用引用传递，这一变化会影响实参</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这也是为什么我们可以见到，在各种排序的算法当中，可以使用一个辅助的swap方法（需传入int[]以及交换的两个index）对整形数组进行改动了。</p><p>这是这个系列第3篇文章（不包括视频），简单讲解了两种不一样的传参方法。希望同学们对两种方法的不同有所了解，并熟悉他们在Java中的应用。</p>]]></content>
      
      
        <tags>
            
            <tag> Java APComputerScience </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个有趣的知乎问题实现</title>
      <link href="/2018/04/20/interesting-Zhihu-question/"/>
      <url>/2018/04/20/interesting-Zhihu-question/</url>
      <content type="html"><![CDATA[<p>前几天在知乎上看到了这样一个有趣的问题：</p><p><font color="blue"><strong>男友让我打十万个「对不起」，汉字标上多少遍。如何快速实现？</strong></font><br><strong>链接:</strong> <a href="https://www.zhihu.com/question/27229082/answer/369776555" target="_blank" rel="noopener">https://www.zhihu.com/question/27229082/answer/369776555</a><br><a id="more"></a><br>感觉挺有意思，毕竟题目要求“汉字标上”，所以是不能用下面这种简单的写法了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saySorry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10001</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"对不起,"</span> + i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上，题目的难点也就是在于如何把0到10000的阿拉伯数字（即 <code>int</code> )转化为中文数字表达（即 <code>String</code> )。在不借用外部类库的情况下，我自己用遍历的方法写出了一个可以表达 1 到 99999 中文表达的Java实现。由于iteration的方便性，我的实现目前来看比大多数知乎回答要更加精简。</p><h3><font color="green">I: Test Case</font></h3><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(num2Chinese(<span class="number">3</span>));</span><br><span class="line">    System.out.println(num2Chinese(<span class="number">30001</span>));</span><br><span class="line">    System.out.println(num2Chinese(<span class="number">10203</span>));</span><br><span class="line">    System.out.println(num2Chinese(<span class="number">39182</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">三</span><br><span class="line">三万零一</span><br><span class="line">一万零二百零三</span><br><span class="line">三万九千一百八十二</span><br></pre></td></tr></table></figure><br><br>可以看出，上述程序很好的实现了中文语义，包括数字后“万”，“千”等单位的添加以及“零”作为补足。那么我们下面就来看一下实现这样一个程序需要考虑的需求有哪些。<br><br><h3><font color="green">II: Requirements</font></h3><ol><li>对于每一数位，都需要将数位上的数字转化为 <code>中文数字+单位</code> 的形式。比如9325，那么千位上的 9 要变成“九千”，其中“九”为数字，“千”为单位。注意这一个需求在各位数的时候要忽略，毕竟上面例子中的 5 输出就为“五”而非“五一”。</li><li>如果数位中有 0 的存在，我们要分为两种情况，第一种就是在非0数字之间出现0。例如 9034，那么要做到的就是在“九千”后面加上一个“零”，然后继续输出“34”。注意就是输出0的时候不需要再输出数位的单位，这一点与 （1）冲突，所以在程序中会使用 <code>if - else</code> 的方式处理。</li><li><font color="red">然而上一点又有一个特殊情况!</font> 考虑这一个例子：90034。根据中文语义应该输出<strong>“九万零三十四”</strong>。看得出来，虽然中间有两个零（千位和百位)，但是实际输出只输出一个。那么程序中要做的就是判断在之前已经添加了一个“零”了，如果是则不继续添加。但如果两个零所在位置不连续，则两个零都要添加：比如 90203 应该输出<strong>“九万零二百零三”</strong>。所以我们会设定一个全局的 <code>boolean</code> 值，每次添加零都进行判断，在添加了零之后变为false，然后在添加不为零的数字后恢复位true。</li><li>继续第 (2) 点的另外一个情况。如果是在数字末尾的0，比如32000，那么我们会完全忽视掉（“三万二千”）。这种情况只需要判断数字z最后一位是否为 0 就可以了。程序中我们可以在循环的过程中按照 1-3 的规则先走，完全忽略第4点，最后在对要输出的字符串进行处理（删除掉末尾的“零”）。</li></ol><p> <strong>我们下面来看看源代码。</strong></p><p></p><h3><font color="green">III: Implementation</font></h3><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">printSorryWithChinese</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="string">"零"</span>);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">"一"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">"二"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">"三"</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">"四"</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">"五"</span>);</span><br><span class="line">        map.put(<span class="number">6</span>, <span class="string">"六"</span>);</span><br><span class="line">        map.put(<span class="number">7</span>, <span class="string">"七"</span>);</span><br><span class="line">        map.put(<span class="number">8</span>, <span class="string">"八"</span>);</span><br><span class="line">        map.put(<span class="number">9</span>, <span class="string">"九"</span>);</span><br><span class="line">        map.put(<span class="number">10</span>, <span class="string">"十"</span>);</span><br><span class="line">        map.put(<span class="number">100</span>, <span class="string">"百"</span>);</span><br><span class="line">        map.put(<span class="number">1000</span>, <span class="string">"千"</span>);</span><br><span class="line">        map.put(<span class="number">10000</span>, <span class="string">"万"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">num2Chinese</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">boolean</span> addZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> input = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">10000</span>; num &gt;=<span class="number">1</span>; num = num / <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mod = n / num;</span><br><span class="line">            <span class="keyword">if</span> (mod != <span class="number">0</span>) &#123;</span><br><span class="line">                buffer.append(map.get(mod));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (num != <span class="number">1</span>)</span><br><span class="line">                    buffer.append(map.get(num));</span><br><span class="line"></span><br><span class="line">                addZero = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length() != <span class="number">0</span> &amp;&amp; addZero &amp;&amp; num != <span class="number">1</span>) &#123;</span><br><span class="line">                buffer.append(map.get(<span class="number">0</span>));</span><br><span class="line">                addZero = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            n = n % num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((input+<span class="string">""</span>).endsWith(<span class="string">"0"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> buffer.toString().substring(<span class="number">0</span>, buffer.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在上面讲完需求之后，具体的实现就很简单了。下面基于代码讲一下具体的思路：</p><p><font color="red"><strong>Step1:</strong></font> 创建并使用一个Map来承载数字=&gt;中文的映射关系<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个整型对应字符串的 key-value HashMap</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    map.put(<span class="number">0</span>, <span class="string">"零"</span>);</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"一"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"二"</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">"三"</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">"四"</span>);</span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">"五"</span>);</span><br><span class="line">    map.put(<span class="number">6</span>, <span class="string">"六"</span>);</span><br><span class="line">    map.put(<span class="number">7</span>, <span class="string">"七"</span>);</span><br><span class="line">    map.put(<span class="number">8</span>, <span class="string">"八"</span>);</span><br><span class="line">    map.put(<span class="number">9</span>, <span class="string">"九"</span>);</span><br><span class="line">    map.put(<span class="number">10</span>, <span class="string">"十"</span>);</span><br><span class="line">    map.put(<span class="number">100</span>, <span class="string">"百"</span>);</span><br><span class="line">    map.put(<span class="number">1000</span>, <span class="string">"千"</span>);</span><br><span class="line">    map.put(<span class="number">10000</span>, <span class="string">"万"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意使用 <code>static</code> 关键词的内容。这一代码段会在类加载阶段将内容注入到 map 中去。</p><p><font color="red"><strong>Step2:</strong></font> 声明变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个StringBuffer用于拼接字符串，在之前的文章中提过使用 “+” 运算符直接拼接速度很慢</span></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">//上文中提到的boolean值，用于判断是否可以添加零</span></span><br><span class="line"><span class="keyword">boolean</span> addZero = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//由于传入的参数int本身会在操作中被改变，所以需要提前用一个新的int承载其原本的值</span></span><br><span class="line"><span class="keyword">int</span> input = n;</span><br></pre></td></tr></table></figure></p><p><font color="red"><strong>Step3:</strong></font> 循环处理（从万位到个位）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从万位开始，每一次除以 10 降低一位，实现循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">10000</span>; num &gt;=<span class="number">1</span>; num = num / <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">//除以位数后的商即是该位数上的数字</span></span><br><span class="line">    <span class="keyword">int</span> mod = n / num;</span><br><span class="line">    <span class="comment">//商不等于0时，比如 90000/10000 = 9</span></span><br><span class="line">    <span class="keyword">if</span> (mod != <span class="number">0</span>) &#123;</span><br><span class="line">        buffer.append(map.get(mod));</span><br><span class="line">        <span class="comment">//上面说过，除了个位数，都要添加代表位数的单位</span></span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">1</span>)</span><br><span class="line">            buffer.append(map.get(num));</span><br><span class="line">        <span class="comment">//如果不是零的情况，要将boolean恢复为true（上面第三点）</span></span><br><span class="line">        addZero = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//商是零的情况，如 9000/10000 = 0</span></span><br><span class="line">    <span class="comment">//进行判断，要求添加的零不能作为返回字符串的开头，并且addZero允许添加零，而且位数不为各位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length() != <span class="number">0</span> &amp;&amp; addZero &amp;&amp; num != <span class="number">1</span>) &#123;</span><br><span class="line">        buffer.append(map.get(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//将addZero调回为false</span></span><br><span class="line">        addZero = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//改变n的值，判断下一位。如95320变为5320。</span></span><br><span class="line">    n = n % num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><font color="red"><strong>Step4:</strong></font> 删除末尾的零<br>这一步很简单，看代码就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((input+<span class="string">""</span>).endsWith(<span class="string">"0"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.toString().substring(<span class="number">0</span>, buffer.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后返回字符串</span></span><br><span class="line"><span class="keyword">return</span> buffer.toString();</span><br></pre></td></tr></table></figure></p><p></p><h2><font color="green">最后总结：</font></h2><br>这个小程序是在AP CS课上无聊完成的。<br>对于这种逻辑相对复杂，要求繁琐的任务，知乎上很多的人直接使用了硬算的办法来解决。这样做的缺点是很大的，比如下次要扩展到一亿或者更大，要改动的地方就很多了。<br>反而，我们要先观察其中的规律，然后想想递归/遍历是否能够完成这一任务。最重要的是要将学会的设计模式运用在其中。<p></p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AP CS复习（2）- Math和Random基础</title>
      <link href="/2018/04/10/AP-CS%E5%A4%8D%E4%B9%A0%EF%BC%882%EF%BC%89-Math%E5%92%8CRandom%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/04/10/AP-CS%E5%A4%8D%E4%B9%A0%EF%BC%882%EF%BC%89-Math%E5%92%8CRandom%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>本来就不是什么高产的人，但是由于AP里面会有一些琐碎的小点，所以干脆简洁的介绍一下。今天讲的就是 <code>java.lang.math</code> 和 <code>java.util.Random</code> 这两个小点。这些方法大家应该都大致懂得使用，<strong>所以过一遍就好了</strong>。</p><a id="more"></a><hr><h2><font color="green">AP考什么?</font></h2><br>按照惯例，先上个传送门：<a href="http://media.collegeboard.com/digitalServices/pdf/ap/ap-computer-science-a-course-description.pdf" target="_blank" rel="noopener">College Board AP CS</a><br><br><strong><code>Java.lang.Math</code> 会考：</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">pow</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">double</span> exponent)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br><br><strong><code>Java.util.Random</code> 会考（其实是FRQ会考）：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> nextInt(int bound);</span><br></pre></td></tr></table></figure><br><br>将这两个类放在一起讲主要是因为他都可以生成伪随机数字（伪随机会在后面重点提到）。<strong>这在回答一些AP FRQ时极为重要。</strong><br><br>&gt; <font color="blue">对于Math的类的其他方法，下面简略用实例一一演示</font><br><br><h3><font color="red">static int abs(int x / double x)</font></h3><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = -<span class="number">20</span>;</span><br><span class="line"><span class="comment">//返回int x的绝对值</span></span><br><span class="line"><span class="keyword">int</span> y = Math.abs(x); <span class="comment">// y = 20</span></span><br><span class="line"><span class="comment">//double 同理</span></span><br></pre></td></tr></table></figure><br><br>这个方法要自己实现也是非常之简单的，只需要通过if-else判断数字的正负然后一律改为正数就可以了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//source源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> -x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>没什么好说的。。。其实AP里面真正要考这个方法的也不多。<br><h3><font color="red">static double pow(double base, double exponent)</font></h3><br>Java中基本的operators很难做到十进制上的乘方操作。<br><strong>P.S. 在二进制层面是可以做到的，如移位运算符</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//表达式&lt;&lt; 3意味着将x的二进制表示向左平移3位，也就是乘以2^3</span></span><br><span class="line"><span class="comment">//原本：00011 -&gt; 对应十进制3</span></span><br><span class="line"><span class="comment">//改变：11000 -&gt; 对应十进制24</span></span><br><span class="line">x = x &lt;&lt; <span class="number">3</span>;</span><br><span class="line">System.out.println(x); <span class="comment">//结果为3*2^3=24</span></span><br></pre></td></tr></table></figure><br><br>但是通过递归或者遍历的方法，可以做到乘方的操作，这也是Math.pow()方法的实现基础（但事实上pow方法调用了C语言完成，并不是一个java本身方法）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算2^5</span></span><br><span class="line"><span class="comment">//虽然参数是double，可以直接传入int值，因为java中int可以被自动转型成double</span></span><br><span class="line"><span class="keyword">double</span> x = Math.pow(<span class="number">2.0</span>, <span class="number">5.0</span>);</span><br><span class="line">System.out.println(x); <span class="comment">//输出32.0</span></span><br></pre></td></tr></table></figure><br><br><strong>可以试着用递归的办法实现这个方法的简略版：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">powWithRecursion</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">double</span> expo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//任何数零次方为1</span></span><br><span class="line">    <span class="keyword">if</span> (expo==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (expo==<span class="number">1</span>) <span class="keyword">return</span> base;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> powWithRecursion(base, expo-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>分析一下上述方法，要求传入的expo必须是<strong><font color="green">positive integer</font></strong>（虽然写着是double），不然就会抛出 <code>StackOverFlowError</code> 。但至少，我们可以利用自己的知识实现一个高级的方法了。<br><br><br><h3><font color="red">static double sqrt(double x)</font></h3><br>顾名思义，这是一个求平方根的操作，在AP考试里考的也不多。要注意的是，当传入的参数为负时，不会抛出 <code>runtimeException</code> , 返回的结果却也并不是一般的double数字，而是一个静态常量NaN（not a number）。<br>在double类中，这个NaN是这样被定义的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NaN = <span class="number">0.0</span>d / <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><br><br>除了分母为0之外，更神奇的是，这个常量自己与自己不想等，<strong>可谓是六亲不认！</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = (Double.NaN == Double.NaN);</span><br><span class="line">System.out.println(b); <span class="comment">//false;</span></span><br><span class="line"><span class="comment">//所以唯一用于判断NaN的办法是Double.isNaN();</span></span><br></pre></td></tr></table></figure><br><br>在这个特例之外，sqrt方法就兢兢业业的返回输入数字的平方根，仅此而已了。<br><br><br>———-<br>在讲Random有关的方法之前，这里也稍作延伸，再简略补充几个Math类中的方法，并且讲一下使用它的注意事项。<br><strong>上代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">20</span>,<span class="number">30</span>); <span class="comment">//取最大数字30</span></span><br><span class="line">Math.min(<span class="number">20</span>,<span class="number">30</span>); <span class="comment">//取最小数字20</span></span><br><span class="line">Math.round(<span class="number">20.3</span>); <span class="comment">//四舍五入取20</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">//2.718...常量</span></span><br><span class="line"><span class="keyword">double</span> pie = Math.PI; <span class="comment">//3.14159...常量</span></span><br></pre></td></tr></table></figure><br><br>这里尤为注意的是最后两个静态常量值π和e，善于使用系统给定好的常量是java编程的一个非常好的习惯。这里顺带提一下<strong><font color="red">魔法值（magic number）</font></strong>的概念：<br><br><strong>代码实例1：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getCirclePerimeter</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6.28318</span>*radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这是一个通过输入半径计算圆周长的简单方法 <code>（C=2πr）</code> 。然而不认真看，你会惊讶：<strong>这个6.28318是哪里来的？这是什么鬼？</strong> 哦，想了好久才发现这是3.14159和2的乘积啊！这样的数字，既不是类的成员常量，在方法内部也没有local variable承载，<strong>就像是魔术师突然变出来的一样，给阅读代码的人增添很多麻烦！</strong><br><center><font color="red">所以这样的代码是要尽力避免的！</font></center><br><strong>代码实例2：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getCirclePerimeter</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*Math.PI*radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>是不是清晰明了多了？</strong> <code>Math.PI</code> 清晰，易读，即使不用注释也可以让阅读者轻松理解。何况Math类中的π的精准度极高，足够应付大多数计算场景。<br><br><br><br><br>———-<br><br><br><h3><font color="blue">Math类和异常</font></h3><br>这是第二个有趣且需要强调的点。我们来复习一遍：<br><br><strong>在Java中的Exception分为Checked和Unchecked两种</strong>，其中运行时异常 <code>（RuntimeException）</code> 属于 <code>unchecked exception</code>。并且，Java强制规定所有的 <code>checked exception</code> 都需要用某种方式处理（try/catch或者throws）。具体关于Java异常的知识AP不做过多要求，之后可能单独写博客总结。<br><br>显而易见，在Math类中很多情况我们要考虑参数所造成的异常（如负数开方/除0），而且这些异常在编译期间都是不会捕获的，只能等到 <code>runtime</code> 才能看得出来。这就是为什么比较有名的 <code>ArithmaticException</code> 是运行时异常的原因了，编译器也不会提醒你去捕获。<br><br>那么在写代码的时候（AP考试之外），就要自己留意参数了，不要想指望IDE来帮助你。<br><br><h2><font color="red">Random方法和伪随机</font></h2><br>我们先来看一下Math.random方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/没有参数</span></span><br><span class="line"><span class="comment">/返回一个在[0，1)之间的浮点值（左闭右开），如0.7762457478958932</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br><br><strong>看得出来，这个random出来的double值是很难直接使用的。</strong>一般来讲，如果要生成0到100之间的整数，我们可以这样做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于右边为开区间，故乘以100+1=101</span></span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>) (Math.random()*<span class="number">101</span>);</span><br></pre></td></tr></table></figure><br><br>上述操作先放大random值的倍数，然后转型为int。AP中有类似的考法，<strong>重点就在于理解其开闭区间的性质和放大的方法。</strong><br><br>相比之下，Random类的操作就更加方便。下面是Random类的两个构造函数，其中第二个我们会重点讲：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">Random random = <span class="keyword">new</span> Random(<span class="keyword">long</span> seed);</span><br></pre></td></tr></table></figure><br><br>使用上面，我们可以利用 <code>nextInt(int bound)</code> 方法得到随机数, <strong>返回一个0到bound-1之间的整数（也是左闭右开）。</strong><br><br>在AP考试中，有可能我们要设计一个这样的方法：<br><strong><font color="blue">一个盒子中有很多球（使用一个ArrayList装载），然后不放回的随机从中抽球。</font></strong><br><br>下面展示random在这个方法中的使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">box</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Ball&gt; list;</span><br><span class="line">    <span class="comment">//构造方法中传入一个装有球的arraylist</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">box</span><span class="params">(ArrayList&lt;Ball&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保证不放回的取出球。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Ball <span class="title">pickBall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Ball pick = <span class="keyword">this</span>.list.remove(random.nextInt(list.length));</span><br><span class="line">        <span class="keyword">return</span> pick;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>上面pickBall方法里的一调用看懂了吧。通过巧妙的使用list.length作为生成随机数的上界，<strong>可以保证不会出现list取出球之后长度变短，进而导致</strong>   <code>indexOutOfBoundException</code>。<br><br><br>———-<br><br>最后的最后，稍微延伸一下，讲一下编程中的伪随机概念。我们先有趣的设计一个代码，其中我们使用了Random的第二个构造函数（传入一个long seed）:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Random ran1 = <span class="keyword">new</span> Random(<span class="number">100</span>);</span><br><span class="line">Random ran2 = <span class="keyword">new</span> Random(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"第一个随机的第"</span> +i+<span class="string">"个数字： "</span>+ran1.nextInt(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">"第二个随机的第"</span> +i+<span class="string">"个数字： "</span>+ran2.nextInt(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>结果令人震惊！！！</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第一个random的第<span class="number">0</span>个数字： <span class="number">5</span></span><br><span class="line">第二个random的第<span class="number">0</span>个数字： <span class="number">5</span></span><br><span class="line">第一个random的第<span class="number">1</span>个数字： <span class="number">0</span></span><br><span class="line">第二个random的第<span class="number">1</span>个数字： <span class="number">0</span></span><br><span class="line">第一个random的第<span class="number">2</span>个数字： <span class="number">4</span></span><br><span class="line">第二个random的第<span class="number">2</span>个数字： <span class="number">4</span></span><br><span class="line">第一个random的第<span class="number">3</span>个数字： <span class="number">8</span></span><br><span class="line">第二个random的第<span class="number">3</span>个数字： <span class="number">8</span></span><br><span class="line">第一个random的第<span class="number">4</span>个数字： <span class="number">1</span></span><br><span class="line">第二个random的第<span class="number">4</span>个数字： <span class="number">1</span></span><br></pre></td></tr></table></figure><br><br><strong>两个不同的random实例竟然每一次得到的随机数都是相同的？？？！！！</strong><br><br><br>———-<br>我们来思考一个问题：如果编程实现随机数是需要一个算法来计算的，那么：<br><h3><font color="red">“算法”和“随机”本身难道不是冲突的吗？？</font></h3><br>算法要求有特定的公式生成“随机”数字，那么掌握这个公式的人就可以知道随机生成的规律，那么随机也就不是随机了。<br><br>正式如此，像Random或者Math类这样的随机都是<strong>伪随机。</strong><br><br>事实上，<strong>java的伪随机实现是通过线性同余的方程实现的</strong>，基本公式如下：<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/5544515?fr=aladdin" target="_blank" rel="noopener">（百度百科）</a><br><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0=baike92,5,5,92,30/sign=f89cec91c1ef7609280691cd4fb4c8a9/50da81cb39dbb6fda60e0d2a0324ab18972b3761.jpg" alt="此处输入图片的描述"><br>简单来说，公式里的a，c和m都是整数常量，而随机数Xn+1的数值和上一个随机数Xn相关。那么第一个随机数和谁相关呢？哦，这时候上面代码里的long seed就有了意义了，这一个seed（种子）值就是用来确定第一个随机数用的。根据这个公式，种子数相等的两个random实例每一次随机出的数字都会是一样的（因为随机数只和上一个随机数有关）。<br><br><strong>但更要注意的是！！种子的值和随机出来的数字范围没有关系！</strong>虽然上面代码里的种子为100，但是nextInt产生的随机数范围还是在0和30之间的！<br><br>最后的问题是，刚刚代码里面，不带参数构造的random实例，也就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br></pre></td></tr></table></figure><br><br>它的种子又是什么呢？<strong>我们看一下源码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这个方法里面有二进制的运算符。但抛开这个不谈，我们发现了不带参的构造方法内部调用了带参的构造方法，而参数则于系统当前时间和一个叫 <code>seedUniquifier()</code> 方法的返回值相关。<br><br><strong>好了，最后我们讨论一下什么是</strong>“真随机”<strong>吧。</strong><br>既然算法本身无法得到真正的随机数，我们就要寻求计算机外界的帮助。虽然我对量子物理了解不多，但是我们不妨可以这样想：<br><br>既然量子世界中的一些值（如电子的运动）是不可预测的，我们可以通过观测读取这些值然后生成真随机数。<br><br>同理，现在也有以电脑硬件噪声大小（噪声大小在物理上可以看作随机的)作为输入得到随机值的办法。<br><br><h2><center>脑洞大开！！</center></h2><hr><p></p><h2><font color="green">写在最后</font></h2><br>这是本人的第二篇博文。不想只讲一下AP会考的无聊的方法，我在基础上进行延伸讨论了java随机数伪随机的问题和线性同余方程。<p></p><p>本人数学和CS水平都有限，但依然对这些AP不考，但是非常有趣的概念有着很大的热情。这一篇博文不太长，因为我在策划下一个知识点 <code>AP数据结构-数组和ArrayList</code> 的内容。<br>我计划做一个视频讲解list的API，并且带着大家通过泛型和数据结构自己实现一个ArrayList(很简单的啦！)，这个工作会在周末完成！</p><p>如果喜欢我的文章，不妨将它分享给你身边的CS学生或者对CS感兴趣的同学哦！</p>]]></content>
      
      
        <tags>
            
            <tag> Java APComputerScience </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AP CS复习（1）- String类及其API</title>
      <link href="/2018/04/08/AP%20CS%E5%A4%8D%E4%B9%A0%EF%BC%881%EF%BC%89-%20String%E7%B1%BB%E5%8F%8A%E5%85%B6API/"/>
      <url>/2018/04/08/AP%20CS%E5%A4%8D%E4%B9%A0%EF%BC%881%EF%BC%89-%20String%E7%B1%BB%E5%8F%8A%E5%85%B6API/</url>
      <content type="html"><![CDATA[<hr><p>很久之前就有开一个博客写文章的打算然而迟迟未能动笔。最近正好发现没有什么专门复习<font color="red">AP CS</font>的文章，所以就准备自己写一个。仔细想想，很多人会觉得<font color="red">AP CS</font>很水很弱智，所以我希望我写出的东西能够不只是应付AP本身，还要能够挖掘相对底层一点的东西（如某些方法的实现）。<br><strong>第一篇文章就从 <code>Java.lang.String</code> 这个概念讲起，大致概括AP的一些考点和一些额外的概念。</strong></p><h2 id="I-AP考什么"><a href="#I-AP考什么" class="headerlink" title="I: AP考什么?"></a><font color="green">I: AP考什么?</font></h2><p>先上一张图<em>（来自<a href="http://media.collegeboard.com/digitalServices/pdf/ap/ap-computer-science-a-course-description.pdf" target="_blank" rel="noopener">CB Course Description</a>）</em></p><a id="more"></a><p><img src="https://raw.githubusercontent.com/listar2000/java_Projects/master/blogPic/String_01.png" alt="CB对于String类的要求"></p><p>可以看出，AP CS考试中对于String类的要求非常之低，除了通用的懂得如何实例化一个字符串之外，仅需要掌握5（其实是4）种方法就可以舒服的当一个api-caller了。<br>然而，除了懂怎么用之外，<strong>什么时候用</strong>则成为了一个更重要的问题。所以我们还是一个个方法逐一了解一下。</p><p></p><h3><font color="red">int length()</font></h3><br>不用多说，这个最简单的方法返回该字符串的长度。而这个方法常用于for循环中来遍历字符串中的字符。<p></p><p><strong>举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印出字符串"banana"中'a'字符的个数</span></span><br><span class="line">String str = <span class="string">"banana"</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.charAt(i) == <span class="string">'a'</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出为3</span></span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure><p>当然，这里可耻的使用了一个 <code>String.charAt(int index)</code> 的方法，但是不影响理解就好了。关于 <code>length()</code> 能讲的实在不多，毕竟它太基础了。</p><p><strong>稍微深入一点的话</strong>，不难发现String这个类其实是由一个char[]构成的。也就是说，一个”pig”这样的字符串本质上由’p’,’i’,’g’拼接而成。了解这一点，就不难发现String类有这样一个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] arr = &#123;<span class="string">'d'</span>,<span class="string">'o'</span>,<span class="string">'g'</span>&#125;;</span><br><span class="line"><span class="comment">//传入一个char[]作为参数</span></span><br><span class="line">String str = <span class="keyword">new</span> String(arr);</span><br><span class="line"><span class="comment">//输出"dog"</span></span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure></p><p>那么可想而知，<code>length()</code> 的底层实现也非常简单，就是返回char[]的length就可以了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String类中的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###<font color="red">substring(int from, int to)</font>###<br>下一个方法就是大名鼎鼎的 <code>substring</code> 方法。这个方法返回字符串中的一个子字符串，其上界和下界由参数中的from和to控制。为什么说这个方法很牛逼呢，其实是因为各种你想得到的方法都可以由 <code>substring</code> 方法得到。<br><strong>但在这之前，有两点需要注意！</strong></p><blockquote><p>对于给定的参数from和to，返回的子字符串是从 <code>charAt(from)</code> 开始到 <code>charAt(to-1)</code> 为止。换句话说，返回的子字符串的长度应该等于<code>to - from</code>,这样记就不会弄错啦！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"watermelon"</span>;</span><br><span class="line"><span class="comment">//0对应test中的'w'字符，而4却对应的是index为（4-1=3）的'e'字符。</span></span><br><span class="line"><span class="comment">//输出结果为"wate"</span></span><br><span class="line">System.out.println(test.substring(<span class="number">0</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>可想而知，这个方法常常用于截取字符串上，许多的AP FRQ问题都会考到。<br>但是，这里substring方法的用处可不止如此，我们可以通过操纵参数达到意想不到的效果。</p><p><strong>I：获取字符串的最后一个字符</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">//结果为o</span></span><br><span class="line">String lastChar = test.substring(test.length()-<span class="number">1</span>, test.length());</span><br><span class="line"><span class="comment">//上面也可以简写成（运用后面会讲的substring(int from)）</span></span><br><span class="line"><span class="comment">//String lastChar = test.substring(test.length()-1);</span></span><br></pre></td></tr></table></figure></p><p><strong>II: 究极脑经急转弯：如何不用遍历判断一个字符串是否由单一字符组成？</strong></p><p>直接上代码，这个能不能理解都无所谓，只是真的让人感叹substring的强大。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">consistOfSameChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//假设传入的str为"banana"</span></span><br><span class="line">    <span class="comment">//first = "banan" （除了最后一个字符）</span></span><br><span class="line">    String first = str.substring(<span class="number">0</span>, str.length-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//last = "anana" （除了第一个字符）</span></span><br><span class="line">    String last = str.substring(<span class="number">1</span>, str.length());</span><br><span class="line">    <span class="comment">//判断他们是否相等即可判断该字符串是否由同一字符组成</span></span><br><span class="line">    <span class="keyword">return</span> first.equals(last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后，简单提一下 <code>substring(int from)</code> 这个方法，作为前一个方法的重写，这个方法更加的方便，直接返回从给定的index from到字符串末尾的子字符串。本质上:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.substring(<span class="keyword">int</span> from) 和 x.substring(<span class="keyword">int</span> from, x.length()) 相同</span><br></pre></td></tr></table></figure></p><p></p><h3><font color="red">int indexOf()</font></h3><br><strong>又是一个强大的方法！</strong>！<br>本质上idnexOf方法在String类中被复写了4遍。但操蛋又温柔的CB爸爸只要求考其中的一种，即参数为String的那种。<p></p><blockquote><font color="blue">Talk is cheap, show me the code – Linus</font></blockquote><p>我们废话少说，直接上一个清晰易懂的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被匹配的字符串</span></span><br><span class="line">String test = <span class="string">"listar2000"</span>;</span><br><span class="line"><span class="comment">//想要查找的值</span></span><br><span class="line">String match1 = <span class="string">"star"</span>;</span><br><span class="line"><span class="comment">//得出位置1</span></span><br><span class="line"><span class="keyword">int</span> position1 = test.indexOf(match1);</span><br><span class="line"><span class="comment">//输出结果为2，也就是说，首先listar2000中包含star这个子字符串，同时star中的第一个字符s在listar2000中的位置为2，所以返回一个int值=2。</span></span><br><span class="line">System.out.println(position);</span><br><span class="line"><span class="comment">//下面我们再看另一种情况</span></span><br><span class="line">String match2 = <span class="string">"michael"</span>;</span><br><span class="line"><span class="comment">//欸，明明listar2000里面不包含michael啊，怎么办呢?</span></span><br><span class="line"><span class="keyword">int</span> position2 = test.indexOf(match2);</span><br><span class="line"><span class="comment">//int值在字符串中不包含的情况下返回-1</span></span><br><span class="line">System.out.println(position2);</span><br></pre></td></tr></table></figure></p><p>言简意赅，雷厉风行。如果有，返回子字符串的起始位置；如果没有，返回-1。清晰明了。这样也可以看出，indexOf这个方法可以用来做匹配，查询字符串中是否包含某个段落。下面是最近CS Project里面的一段真实代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串中是否含有某个子字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSubstring</span><span class="params">(String str, String match)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.indexOf(match)&gt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，其实String类的API中早就已经预设好类似 <code>contains</code> 这样的方法直接返回一个boolean告诉你字符串是否包含。但是灵活掌握一种方法同时融会贯通的能力也是非常重要的。另一方面，这里也想着重强调官方文档的重要性，多看文档，会发现很多方法早就预设在jdk里面，<strong>不需要像我刚刚一样重复造轮子</strong>，非常麻烦! <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html" target="_blank" rel="noopener">传送门</a></p><p></p><h3><font color="red">int compareTo()</font></h3><br>最后一个方法稍微有点复杂，所以我们从其源码的implementation角度来理解这个方法的具体功能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到自身和同自身比较的字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="comment">//得到两字符串较短的长度的值，如一个长为5，一个为3，则取3。</span></span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="comment">//得到两字符串分别的char[]，刚刚提过这是内置在String类中的成员变量</span></span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">    <span class="comment">//下面开始注意!!</span></span><br><span class="line">    <span class="comment">//从两个字符串的第一个字符开始遍历，到刚刚得到的最短长度为止</span></span><br><span class="line">    <span class="comment">//将每一个index的字符进行比较，如果不相同则返回c1 - c2的差</span></span><br><span class="line">    <span class="comment">//注意，java中char类型的差为ASC-II码表上对应的值。比如A的值为65，a     的值却是97，那么'a'-'A'就等于32.</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果在0到lim范围内两字符串的字符都相同，那么返回的int值不再是ASC-II码表编号的差距，而是直接两字符串长度的差！！</span></span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>会发现十分操蛋的一点是，compareTo返回的int值，根据比较的两个字符串的不同，返回时的判定方式也不一样。<strong>要着重记住的点就是，java中char类型比较的是其ASC-II码表的编号差！！</strong></p><p><strong><font color="red">算了，看完了底层实现，我们看一下实例来说明问题吧！</font></strong></p><p><strong>例子1：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"applegood"</span>;</span><br><span class="line">String b = <span class="string">"Apple"</span>;</span><br><span class="line">System.out.println(a.compareTo(b));</span><br><span class="line"><span class="comment">//输出为32</span></span><br></pre></td></tr></table></figure></p><ol><li>执行compareTo方法</li><li>从第一个字符开始遍历，找不同。</li><li>发现第一个字符’a’和’A’就不一样</li><li>根据ASC-II码表，分别找出a（97）和A（65）的编号。</li><li>返回97-65=32.</li></ol><p><strong>例子2：</strong><br>这次只改变了一个字符的大小写，结果截然不同啊！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"applegood"</span>;</span><br><span class="line">String b = <span class="string">"apple"</span>;</span><br><span class="line">System.out.println(a.compareTo(b));</span><br><span class="line"><span class="comment">//输出为4</span></span><br></pre></td></tr></table></figure></p><ol><li>执行compareTo方法</li><li>从第一个字符开始遍历，找不同。</li><li>发现找到apple的末尾，也就是index=4还是一样！</li><li>不干了，直接返回两个字符串长度差，也就是4</li></ol><p><b><font color="red">这到底是什么JB玩意？!</font></b><br><b><font color="red">Java就这样implement的？？？</font></b></p><blockquote><font color="blue">PHP is the best programming language in the world!!<br>Life is short, I use Python!!</font></blockquote><p>好吧说了这么多，反正AP也不会考这么深。但是着<strong>再一次的证明了阅读源码的重要性啊</strong>！！！不然鬼知道这个int返回值是什么东西。只要记住当 <code>compareTo</code> 返回的是0时，那么这两个字符串就是相等了。不过话说用equals不是更好么。。。</p><p></p><h3><font color="red">Beyond AP：来看看String类的魔性设定</font></h3><br>首先我们看一下String这个类中源码的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p>抛开implements的那一大串接口不谈，你会发现一个恐怖的字眼 <code>final class</code><br>更恐怖的是，<strong>作为String根本的成员变量char[]（之前提过），也是final修饰的。</strong>这也意味着，String这个对象本身其实是不可改变的。</p><p>有人马上会说，胡说八道！字符串的拼接是怎么实现的？<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"star"</span>;</span><br><span class="line">test = test + <span class="string">"is handsome"</span>;</span><br></pre></td></tr></table></figure></p><p><strong>这不是改变了吗？</strong><br>但其实，在我们每一次的进行字符串拼接的时候，其实Java底层都是创建了一个新的String对象来承载新的字符串。不信，可以用hashcode()方法测验一下(一般我们认为hashcode相同的两个object指向内存中的同一对象)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String test = <span class="string">"star"</span>;</span><br><span class="line"><span class="comment">//3540562</span></span><br><span class="line">System.out.println(test.hashCode());</span><br><span class="line">test = test + <span class="string">"is handsome"</span>;</span><br><span class="line"><span class="comment">//-632481145</span></span><br><span class="line">System.out.println(test.hashCode());</span><br></pre></td></tr></table></figure></p><p>很明显的，对象改变了。事实上，针对String的hashcode有一个特殊的算法，保证内容相同的字符串拥有相同的hashcode。我们使用拼接改变字符串，自然让hashcode同样有了变化。<br><b><font color="blue">这就带来了一个问题!!</font></b><br>当我们的程序需要频繁的拼接字符串的时候，性能会由于频繁的new对象受到影响。而在Java这一成熟的语言中，要解决这个问题也是非常简单的。既然String是一个不可变的类，那么就用辅助的可变类来帮助进行频繁的拼接操作。如：StringBuffer和StringBuilder。</p><p>下面直接上一篇<a href="https://www.cnblogs.com/Faith-zhang/p/6374834.html" target="_blank" rel="noopener">其他人博客</a>的实验结果：</p><blockquote><p>用String+=拼接字符串的时间27468<br>用String=String+拼接字符串的时间25813<br>用String.concat拼接字符串的时间12265<br>用StringBuffer.append拼接字符串的时间14<br>用StringBuilder.append拼接字符串的时间8 </p></blockquote><p>效果立杆见影，可想而知了吧。。。<br>具体的使用方法这里不多谈，希望大家可以查阅官方文档来获取资讯。</p><hr><p></p><h2><font color="blue">最后</font></h2><br>第一篇博文是有点试试水的心态写的，如有疏漏请多原谅。本文借鉴了少数他人博客和大量官方文档，但最多的还是自己开着IDE进行测试。这里也鼓励各位多多肝码，自己尝试。<br>AP不到一个月了，作为Senior我觉得有时间可以写一下这方面的博客来帮助大家复习。同时，自己的Hexo博客刚开所以没有怎么设置，目前应该是没有留言功能的。所以大家想了解AP CS中的哪方面知识可以微信找我。就这样了！！<p></p>]]></content>
      
      
        <tags>
            
            <tag> Java APComputerScience </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>My First Blog Post!</title>
      <link href="/2018/04/07/My-First-Blog-Post/"/>
      <url>/2018/04/07/My-First-Blog-Post/</url>
      <content type="html"><![CDATA[<p><strong>大家好！！！</strong></p><p>很早之前就想开一个自己的博客来写一些编程/学习/日常的东西。<br>首先考虑了用[CSDN][1]/[简书][2]等平台。然而一想：这也太不Geek了吧。。所以在CSDN上写了几篇sb Java技术文章之后就没有继续了。。</p><p>之后由于学了一些Java Web的技术，就想要自己从前端到后端写一个博客出来（无非就是 <code>JSP + Servlet + MySQL + JavaBean</code> 这一套，连框架都没用）。结果发现自己前端水平实在底下，然后 <code>Java Web</code> 的部署真的是捉急。所以也放弃了。</p><p>最后所以还是选择Hexo这样的博客框架，然后配合Github的免费域名凑合来建博客。<strong>Markdown</strong>现在用的也不好，唉，就这样咯。</p><p><strong>接下来会发布一些技术文章吧。。。或许。。。可能吧</strong></p>]]></content>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/04/07/hello-world/"/>
      <url>/2018/04/07/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
